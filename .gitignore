Ø§Ù„Ø¨ØªÙ‡! Ø§ÛŒÙ† Ú©Ø¯ Ù†Ù‡Ø§ÛŒÛŒ `telegram_bot.py` Ø§Ø³Øª:
Action: file_editor view /app/telegram_bot.py
Observation: /app/telegram_bot.py:
1|import os
2|import asyncio
3|import logging
4|from datetime import datetime, timezone
5|from typing import Dict, List, Optional, Tuple
6|import numpy as np
7|import pandas as pd
8|import matplotlib
9|matplotlib.use('Agg')
10|import matplotlib.pyplot as plt
11|from matplotlib.patches import Rectangle
12|import io
13|import requests
14|from telegram import Bot
15|from telegram.error import TelegramError
16|from dotenv import load_dotenv
17|from pathlib import Path
18|
19|# Load environment variables
20|ROOT_DIR = Path(__file__).parent
21|load_dotenv(ROOT_DIR / '.env')
22|
23|# Configure logging
24|logging.basicConfig(
25|    level=logging.INFO,
26|    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
27|)
28|logger = logging.getLogger(__name__)
29|
30|# Bot Configuration
31|BOT_TOKEN = os.environ.get('BOT_TOKEN', '8363442271:AAHGrIjbCz1PX10qERyRecxY6UUxbfW-8Es')
32|CHANNEL_ID = os.environ.get('CHANNEL_ID', '@your_channel')
33|
34|logger.info(f"âœ… Bot Token loaded: {BOT_TOKEN[:10]}...")
35|logger.info(f"âœ… Channel ID: {CHANNEL_ID}")
36|
37|# No Database - Memory only
38|USE_DATABASE = False
39|logger.info("ðŸ’¾ Running in memory-only mode (no database)")
40|
41|# Trading pairs
42|SYMBOLS = {
43|    'bitcoin': {'name': 'Bitcoin', 'ticker': 'BTC'},
44|    'ethereum': {'name': 'Ethereum', 'ticker': 'ETH'},
45|    'shiba-inu': {'name': 'Shiba Inu', 'ticker': 'SHIB'},
46|    'cardano': {'name': 'Cardano', 'ticker': 'ADA'},
47|    'the-open-network': {'name': 'Toncoin', 'ticker': 'TON'},
48|    'solana': {'name': 'Solana', 'ticker': 'SOL'},
49|    'binancecoin': {'name': 'BNB', 'ticker': 'BNB'}
50|}
51|
52|TIMEFRAMES = ['15m', '1h']
53|
54|
55|class CryptoDataFetcher:
56|    """Fetch crypto data from CryptoCompare"""
57|    
58|    def __init__(self):
59|        self.base_url = "https://min-api.cryptocompare.com/data"
60|        self.session = requests.Session()
61|        self.api_key = os.environ.get('CRYPTOCOMPARE_API_KEY', '')
62|        
63|        if self.api_key:
64|            logger.info("âœ… CryptoCompare API key loaded")
65|        else:
66|            logger.info("âš ï¸ No CryptoCompare API key - using free tier")
67|        
68|    def get_ohlcv(self, coin_id: str, timeframe: str, limit: int = 200) -> pd.DataFrame:
69|        """Get OHLCV data from CryptoCompare"""
70|        try:
71|            ticker = SYMBOLS[coin_id]['ticker']
72|            
73|            if timeframe == '15m':
74|                endpoint = f"{self.base_url}/v2/histominute"
75|                actual_limit = min(limit * 15, 2000)
76|                params = {
77|                    'fsym': ticker,
78|                    'tsym': 'USDT',
79|                    'limit': actual_limit,
80|                    'aggregate': 15
81|                }
82|            else:  # 1h
83|                endpoint = f"{self.base_url}/v2/histohour"
84|                actual_limit = min(limit, 2000)
85|                params = {
86|                    'fsym': ticker,
87|                    'tsym': 'USDT',
88|                    'limit': actual_limit
89|                }
90|            
91|            if self.api_key:
92|                params['api_key'] = self.api_key
93|            
94|            response = self.session.get(endpoint, params=params, timeout=15)
95|            response.raise_for_status()
96|            data = response.json()
97|            
98|            if data.get('Response') == 'Error':
99|                logger.error(f"API Error: {data.get('Message')}")
100|                return None
101|            
102|            if 'Data' not in data or 'Data' not in data['Data']:
103|                return None
104|            
105|            ohlcv_data = data['Data']['Data']
106|            df = pd.DataFrame(ohlcv_data)
107|            
108|            if df.empty:
109|                return None
110|            
111|            df = df[['time', 'open', 'high', 'low', 'close', 'volumeto']].copy()
112|            df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
113|            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s')
114|            df = df[(df['open'] > 0) & (df['high'] > 0) & (df['low'] > 0) & (df['close'] > 0)]
115|            
116|            return df.reset_index(drop=True)
117|            
118|        except Exception as e:
119|            logger.error(f"âŒ Error fetching data for {coin_id}: {e}")
120|            return None
121|    
122|    def get_current_price(self, coin_id: str) -> float:
123|        """Get current price"""
124|        try:
125|            ticker = SYMBOLS[coin_id]['ticker']
126|            url = f"{self.base_url}/price"
127|            params = {'fsym': ticker, 'tsyms': 'USDT'}
128|            
129|            if self.api_key:
130|                params['api_key'] = self.api_key
131|            
132|            response = self.session.get(url, params=params, timeout=10)
133|            response.raise_for_status()
134|            data = response.json()
135|            
136|            return data.get('USDT')
137|            
138|        except Exception as e:
139|            logger.error(f"âŒ Error fetching price for {coin_id}: {e}")
140|            return None
141|
142|
143|data_fetcher = CryptoDataFetcher()
144|
145|
146|class SmartMoneyAnalyzer:
147|    """Smart Money Concept Analyzer"""
148|    
149|    def __init__(self):
150|        self.lookback_periods = 50
151|        self.min_rr_ratio = 2.0
152|        self.volume_threshold = 1.5
153|        
154|    def detect_swing_points(self, df: pd.DataFrame) -> Tuple[List, List]:
155|        """Detect Swing Highs and Swing Lows"""
156|        swing_highs = []
157|        swing_lows = []
158|        
159|        for i in range(2, len(df) - 2):
160|            if (df['high'].iloc[i] > df['high'].iloc[i-1] and 
161|                df['high'].iloc[i] > df['high'].iloc[i-2] and
162|                df['high'].iloc[i] > df['high'].iloc[i+1] and 
163|                df['high'].iloc[i] > df['high'].iloc[i+2]):
164|                swing_highs.append({
165|                    'index': i,
166|                    'price': df['high'].iloc[i],
167|                    'time': df.index[i]
168|                })
169|            
170|            if (df['low'].iloc[i] < df['low'].iloc[i-1] and 
171|                df['low'].iloc[i] < df['low'].iloc[i-2] and
172|                df['low'].iloc[i] < df['low'].iloc[i+1] and 
173|                df['low'].iloc[i] < df['low'].iloc[i+2]):
174|                swing_lows.append({
175|                    'index': i,
176|                    'price': df['low'].iloc[i],
177|                    'time': df.index[i]
178|                })
179|        
180|        return swing_highs, swing_lows
181|    
182|    def detect_bos_choch(self, df: pd.DataFrame, swing_highs: List, swing_lows: List) -> Dict:
183|        """Detect Break of Structure (BOS) and Change of Character (CHoCH)"""
184|        if len(swing_highs) < 2 or len(swing_lows) < 2:
185|            return None
186|        
187|        last_swing_high = swing_highs[-1]['price']
188|        last_swing_low = swing_lows[-1]['price']
189|        current_price = df['close'].iloc[-1]
190|        
191|        if current_price > last_swing_high:
192|            return {
193|                'type': 'BOS_BULLISH',
194|                'signal': 'LONG',
195|                'level': last_swing_high
196|            }
197|        
198|        if current_price < last_swing_low:
199|            return {
200|                'type': 'BOS_BEARISH',
201|                'signal': 'SHORT',
202|                'level': last_swing_low
203|            }
204|        
205|        return None
206|    
207|    def detect_order_blocks(self, df: pd.DataFrame, signal_type: str) -> Optional[Dict]:
208|        """Detect Order Blocks"""
209|        order_blocks = []
210|        
211|        for i in range(len(df) - 10, len(df) - 1):
212|            candle = df.iloc[i]
213|            next_candle = df.iloc[i + 1]
214|            
215|            if signal_type == 'LONG':
216|                if (candle['close'] < candle['open'] and 
217|                    next_candle['close'] > next_candle['open'] and
218|                    (next_candle['close'] - next_candle['open']) > 2 * abs(candle['close'] - candle['open'])):
219|                    order_blocks.append({
220|                        'type': 'BULLISH_OB',
221|                        'high': candle['high'],
222|                        'low': candle['low'],
223|                        'index': i
224|                    })
225|            
226|            elif signal_type == 'SHORT':
227|                if (candle['close'] > candle['open'] and 
228|                    next_candle['close'] < next_candle['open'] and
229|                    (next_candle['open'] - next_candle['close']) > 2 * abs(candle['close'] - candle['open'])):
230|                    order_blocks.append({
231|                        'type': 'BEARISH_OB',
232|                        'high': candle['high'],
233|                        'low': candle['low'],
234|                        'index': i
235|                    })
236|        
237|        return order_blocks[-1] if order_blocks else None
238|    
239|    def detect_fvg(self, df: pd.DataFrame) -> List[Dict]:
240|        """Detect Fair Value Gaps"""
241|        fvgs = []
242|        
243|        for i in range(1, len(df) - 1):
244|            prev_candle = df.iloc[i - 1]
245|            next_candle = df.iloc[i + 1]
246|            
247|            if next_candle['low'] > prev_candle['high']:
248|                fvgs.append({
249|                    'type': 'BULLISH_FVG',
250|                    'top': next_candle['low'],
251|                    'bottom': prev_candle['high'],
252|                    'index': i
253|                })
254|            
255|            if next_candle['high'] < prev_candle['low']:
256|                fvgs.append({
257|                    'type': 'BEARISH_FVG',
258|                    'top': prev_candle['low'],
259|                    'bottom': next_candle['high'],
260|                    'index': i
261|                })
262|        
263|        return fvgs[-3:] if fvgs else []
264|    
265|    def calculate_premium_discount(self, df: pd.DataFrame, swing_highs: List, swing_lows: List) -> Dict:
266|        """Calculate Premium and Discount Zones"""
267|        if not swing_highs or not swing_lows:
268|            return None
269|        
270|        recent_high = max([sh['price'] for sh in swing_highs[-3:]])
271|        recent_low = min([sl['price'] for sl in swing_lows[-3:]])
272|        
273|        range_size = recent_high - recent_low
274|        current_price = df['close'].iloc[-1]
275|        
276|        premium_threshold = recent_low + (range_size * 0.5)
277|        equilibrium = recent_low + (range_size * 0.5)
278|        
279|        if current_price >= premium_threshold:
280|            zone = 'PREMIUM'
281|        else:
282|            zone = 'DISCOUNT'
283|        
284|        return {
285|            'zone': zone,
286|            'high': recent_high,
287|            'low': recent_low,
288|            'equilibrium': equilibrium,
289|            'current': current_price
290|        }
291|    
292|    def calculate_ema(self, df: pd.DataFrame, period: int) -> pd.Series:
293|        """Calculate EMA"""
294|        return df['close'].ewm(span=period, adjust=False).mean()
295|    
296|    def calculate_atr(self, df: pd.DataFrame, period: int = 14) -> float:
297|        """Calculate Average True Range"""
298|        high_low = df['high'] - df['low']
299|        high_close = np.abs(df['high'] - df['close'].shift())
300|        low_close = np.abs(df['low'] - df['close'].shift())
301|        
302|        ranges = pd.concat([high_low, high_close, low_close], axis=1)
303|        true_range = np.max(ranges, axis=1)
304|        atr = true_range.rolling(period).mean().iloc[-1]
305|        
306|        return atr
307|    
308|    def check_volume_confirmation(self, df: pd.DataFrame) -> bool:
309|        """Volume confirmation"""
310|        if len(df) < 20:
311|            return False
312|        
313|        avg_volume = df['volume'].tail(20).mean()
314|        recent_volume = df['volume'].tail(5).mean()
315|        
316|        return recent_volume >= (avg_volume * self.volume_threshold)
317|    
318|    def check_trend_alignment(self, df: pd.DataFrame, signal_direction: str) -> bool:
319|        """Check trend alignment"""
320|        ema_20 = self.calculate_ema(df, 20)
321|        ema_50 = self.calculate_ema(df, 50)
322|        
323|        current_price = df['close'].iloc[-1]
324|        
325|        if signal_direction == 'LONG':
326|            return ema_20.iloc[-1] > ema_50.iloc[-1] and current_price > ema_20.iloc[-1]
327|        else:
328|            return ema_20.iloc[-1] < ema_50.iloc[-1] and current_price < ema_20.iloc[-1]
329|    
330|    def generate_signal(self, coin_id: str, timeframe: str) -> Optional[Dict]:
331|        """Generate trading signal"""
332|        try:
333|            df = data_fetcher.get_ohlcv(coin_id, timeframe, limit=150)
334|            
335|            if df is None or len(df) < 60:
336|                return None
337|            
338|            df.set_index('timestamp', inplace=True)
339|            
340|            swing_highs, swing_lows = self.detect_swing_points(df)
341|            
342|            if len(swing_highs) < 3 or len(swing_lows) < 3:
343|                return None
344|            
345|            structure = self.detect_bos_choch(df, swing_highs, swing_lows)
346|            
347|            if not structure:
348|                return None
349|            
350|            volume_confirmed = self.check_volume_confirmation(df)
351|            if not volume_confirmed:
352|                return None
353|            
354|            trend_aligned = self.check_trend_alignment(df, structure['signal'])
355|            if not trend_aligned:
356|                return None
357|            
358|            order_block = self.detect_order_blocks(df, structure['signal'])
359|            if not order_block:
360|                return None
361|            
362|            fvgs = self.detect_fvg(df)
363|            pd_zone = self.calculate_premium_discount(df, swing_highs, swing_lows)
364|            
365|            current_price = df['close'].iloc[-1]
366|            atr = self.calculate_atr(df)
367|            
368|            ema_20 = self.calculate_ema(df, 20)
369|            ema_50 = self.calculate_ema(df, 50)
370|            
371|            valid_signal = False
372|            
373|            if structure['signal'] == 'LONG':
374|                if pd_zone and pd_zone['zone'] == 'DISCOUNT':
375|                    valid_signal = True
376|                    entry_price = current_price
377|                    stop_loss = order_block['low'] - (atr * 0.5)
378|                    risk = entry_price - stop_loss
379|                    
380|                    target1 = entry_price + (risk * 2.0)
381|                    target2 = entry_price + (risk * 3.0)
382|                    target3 = entry_price + (risk * 4.0)
383|            
384|            elif structure['signal'] == 'SHORT':
385|                if pd_zone and pd_zone['zone'] == 'PREMIUM':
386|                    valid_signal = True
387|                    entry_price = current_price
388|                    stop_loss = order_block['high'] + (atr * 0.5)
389|                    risk = stop_loss - entry_price
390|                    
391|                    target1 = entry_price - (risk * 2.0)
392|                    target2 = entry_price - (risk * 3.0)
393|                    target3 = entry_price - (risk * 4.0)
394|            
395|            if not valid_signal:
396|                return None
397|            
398|            rr_ratio = abs(target1 - entry_price) / risk
399|            if rr_ratio < self.min_rr_ratio:
400|                return None
401|            
402|            risk_percent = (risk / entry_price) * 100
403|            if risk_percent < 1.5:
404|                leverage = 10
405|            elif risk_percent < 2.5:
406|                leverage = 7
407|            elif risk_percent < 4:
408|                leverage = 5
409|            else:
410|                leverage = 3
411|            
412|            signal = {
413|                'coin_id': coin_id,
414|                'symbol': SYMBOLS[coin_id]['ticker'] + '/USDT',
415|                'timeframe': timeframe,
416|                'direction': structure['signal'],
417|                'entry_price': round(entry_price, 8),
418|                'stop_loss': round(stop_loss, 8),
419|                'targets': [
420|                    round(target1, 8),
421|                    round(target2, 8),
422|                    round(target3, 8)
423|                ],
424|                'leverage': leverage,
425|                'structure_type': structure['type'],
426|                'order_block': order_block,
427|                'fvgs': fvgs,
428|                'pd_zone': pd_zone,
429|                'df': df,
430|                'swing_highs': swing_highs,
431|                'swing_lows': swing_lows,
432|                'ema_20': ema_20,
433|                'ema_50': ema_50,
434|                'atr': atr,
435|                'rr_ratio': rr_ratio,
436|                'timestamp': datetime.now(timezone.utc)
437|            }
438|            
439|            return signal
440|            
441|        except Exception as e:
442|            logger.error(f"âŒ Error generating signal for {coin_id}: {e}")
443|            return None
444|
445|
446|class ChartGenerator:
447|    """Professional chart generator"""
448|    
449|    @staticmethod
450|    def create_chart(signal: Dict) -> io.BytesIO:
451|        """Create candlestick chart with SMC analysis"""
452|        try:
453|            df = signal['df'].tail(100)
454|            
455|            fig, ax = plt.subplots(figsize=(20, 12))
456|            fig.patch.set_facecolor('#ffffff')
457|            ax.set_facecolor('#ffffff')
458|            
459|            # Plot EMAs
460|            if 'ema_20' in signal and 'ema_50' in signal:
461|                ema_20_values = signal['ema_20'].tail(100).values
462|                ema_50_values = signal['ema_50'].tail(100).values
463|                
464|                ax.plot(range(len(ema_20_values)), ema_20_values, 
465|                       color='#2962FF', linewidth=2, label='EMA 20', alpha=0.8, zorder=2)
466|                ax.plot(range(len(ema_50_values)), ema_50_values, 
467|                       color='#FF6D00', linewidth=2, label='EMA 50', alpha=0.8, zorder=2)
468|            
469|            # Plot candles
470|            for idx in range(len(df)):
471|                row = df.iloc[idx]
472|                
473|                if pd.isna(row['open']) or pd.isna(row['close']):
474|                    continue
475|                
476|                is_bullish = row['close'] >= row['open']
477|                candle_color = '#089981' if is_bullish else '#F23645'
478|                
479|                height = abs(row['close'] - row['open'])
480|                if height == 0:
481|                    height = 0.0001
482|                bottom = min(row['open'], row['close'])
483|                
484|                ax.add_patch(Rectangle((idx - 0.4, bottom), 0.8, height, 
485|                                       facecolor=candle_color, edgecolor=candle_color, 
486|                                       alpha=0.9, linewidth=1, zorder=3))
487|                
488|                ax.plot([idx, idx], [row['low'], row['high']], 
489|                       color=candle_color, linewidth=1.5, alpha=0.8, zorder=2)
490|            
491|            # Premium/Discount Zones
492|            if signal.get('pd_zone'):
493|                pd_zone = signal['pd_zone']
494|                ax.axhspan(pd_zone['equilibrium'], pd_zone['high'], 
495|                          alpha=0.08, color='#F23645', label='Premium Zone', zorder=0)
496|                ax.axhspan(pd_zone['low'], pd_zone['equilibrium'], 
497|                          alpha=0.08, color='#089981', label='Discount Zone', zorder=0)
498|                ax.axhline(pd_zone['equilibrium'], color='#787B86', 
499|                          linestyle='--', linewidth=1.5, alpha=0.7, label='Equilibrium', zorder=1)
500|                
501|                # Add labels
502|                ax.text(5, pd_zone['high'], f'RESISTANCE: ${pd_zone["high"]:,.2f}', 
503|                       fontsize=10, color='#F23645', fontweight='bold',
504|                       bbox=dict(boxstyle='round,pad=0.5', facecolor='white', 
505|                                edgecolor='#F23645', linewidth=1.5), zorder=5)
506|                
507|                ax.text(5, pd_zone['low'], f'SUPPORT: ${pd_zone["low"]:,.2f}', 
508|                       fontsize=10, color='#089981', fontweight='bold',
509|                       bbox=dict(boxstyle='round,pad=0.5', facecolor='white', 
510|                                edgecolor='#089981', linewidth=1.5), zorder=5)
511|            
512|            # Order Block
513|            if signal.get('order_block'):
514|                ob = signal['order_block']
515|                ob_color = '#089981' if signal['direction'] == 'LONG' else '#F23645'
516|                ax.axhspan(ob['low'], ob['high'], alpha=0.25, color=ob_color, 
517|                          label='Order Block', zorder=1, edgecolor=ob_color, linewidth=2)
518|                
519|                mid_price = (ob['low'] + ob['high']) / 2
520|                ax.text(len(df) - 15, mid_price, 'ORDER BLOCK', 
521|                       fontsize=11, fontweight='bold', color=ob_color,
522|                       bbox=dict(boxstyle='round,pad=0.5', facecolor='white', 
523|                                edgecolor=ob_color, linewidth=2), zorder=4)
524|            
525|            # Fair Value Gaps
526|            for fvg in signal.get('fvgs', []):
527|                fvg_color = '#2962FF' if 'BULLISH' in fvg['type'] else '#FF6D00'
528|                ax.axhspan(fvg['bottom'], fvg['top'], alpha=0.15, 
529|                          color=fvg_color, zorder=1, linestyle='--', 
530|                          edgecolor=fvg_color, linewidth=1)
531|            
532|            # Swing Points
533|            for sh in signal.get('swing_highs', [])[-8:]:
534|                if sh['index'] < len(df):
535|                    ax.plot(sh['index'], sh['price'], 'v', 
536|                           color='#F23645', markersize=10, markeredgecolor='white', 
537|                           markeredgewidth=1.5, zorder=4)
538|            
539|            for sl in signal.get('swing_lows', [])[-8:]:
540|                if sl['index'] < len(df):
541|                    ax.plot(sl['index'], sl['price'], '^', 
542|                           color='#089981', markersize=10, markeredgecolor='white',
543|                           markeredgewidth=1.5, zorder=4)
544|            
545|            # Entry Point
546|            entry_idx = len(df) - 1
547|            entry_price = signal['entry_price']
548|            entry_color = '#2962FF' if signal['direction'] == 'LONG' else '#F23645'
549|            ax.plot(entry_idx, entry_price, 'D', color=entry_color, markersize=15, 
550|                   markeredgecolor='white', markeredgewidth=2.5, label='ENTRY', zorder=6)
551|            
552|            ax.axhline(entry_price, color=entry_color, linestyle='-', 
553|                      linewidth=2, alpha=0.5, zorder=1)
554|            
555|            # Stop Loss
556|            ax.axhline(signal['stop_loss'], color='#F23645', linestyle='--', 
557|                      linewidth=2.5, label=f"STOP LOSS", alpha=0.9, zorder=2)
558|            
559|            ax.text(len(df) - 8, signal['stop_loss'], f'SL: ${signal["stop_loss"]:,.2f}', 
560|                   fontsize=10, fontweight='bold', color='#F23645',
561|                   bbox=dict(boxstyle='round,pad=0.4', facecolor='white', 
562|                            edgecolor='#F23645', linewidth=2), zorder=5)
563|            
564|            # Targets
565|            target_colors = ['#26A69A', '#00897B', '#00695C']
566|            for i, target in enumerate(signal['targets']):
567|                ax.axhline(target, color=target_colors[i], linestyle='--', 
568|                          linewidth=2.5, label=f"TARGET {i+1}", alpha=0.9, zorder=2)
569|                
570|                ax.text(len(df) - 5, target, f'TP{i+1}: ${target:,.2f}', 
571|                       fontsize=10, fontweight='bold', color=target_colors[i],
572|                       bbox=dict(boxstyle='round,pad=0.4', facecolor='white', 
573|                                edgecolor=target_colors[i], linewidth=2), 
574|                       ha='center', zorder=5)
575|            
576|            # Grid
577|            ax.grid(True, alpha=0.2, color='#E0E3EB', linestyle='-', linewidth=0.5)
578|            ax.set_axisbelow(True)
579|            
580|            # Styling
581|            ax.tick_params(colors='#131722', labelsize=11)
582|            for spine in ax.spines.values():
583|                spine.set_color('#E0E3EB')
584|                spine.set_linewidth(1)
585|            
586|            # Title
587|            direction_emoji = "ðŸŸ¢ LONG" if signal['direction'] == 'LONG' else "ðŸ”´ SHORT"
588|            coin_data = SYMBOLS.get(signal['coin_id'])
589|            title_name = coin_data['name'] if coin_data else signal['symbol']
590|            
591|            title = f"{direction_emoji} | {title_name} ({signal['symbol']}) | {signal['timeframe'].upper()}"
592|            subtitle = f"Smart Money Concept | R/R: 1:{signal.get('rr_ratio', 0):.1f}"
593|            
594|            ax.set_title(title, color='#131722', fontsize=20, fontweight='bold', pad=15)
595|            ax.text(0.5, 1.02, subtitle, transform=ax.transAxes, 
596|                   fontsize=12, ha='center', color='#787B86')
597|            
598|            ax.set_xlabel('Time Period', color='#131722', fontsize=13, fontweight='bold')
599|            ax.set_ylabel('Price (USDT)', color='#131722', fontsize=13, fontweight='bold')
600|            
601|            # Legend
602|            legend = ax.legend(loc='upper left', fontsize=9, framealpha=0.95, 
603|                              facecolor='white', edgecolor='#E0E3EB', 
604|                              shadow=True, ncol=2)
605|            legend.get_frame().set_linewidth(1.5)
606|            
607|            plt.tight_layout()
608|            
609|            buf = io.BytesIO()
610|            plt.savefig(buf, format='png', dpi=150, facecolor='#ffffff', 
611|                       edgecolor='none', bbox_inches='tight')
612|            buf.seek(0)
613|            plt.close()
614|            
615|            return buf
616|            
617|        except Exception as e:
618|            logger.error(f"âŒ Error creating chart: {e}")
619|            return None
620|
621|
622|class TelegramSignalBot:
623|    """Telegram signal bot"""
624|    
625|    def __init__(self):
626|        self.bot = Bot(token=BOT_TOKEN)
627|        self.analyzer = SmartMoneyAnalyzer()
628|        self.chart_gen = ChartGenerator()
629|        self.active_trades_cache = {}
630|        
631|    async def check_active_trades(self) -> Dict[str, Dict]:
632|        """Check active trades from cache"""
633|        return self.active_trades_cache
634|    
635|    async def save_signal(self, signal: Dict, message_id: int):
636|        """Save signal to cache"""
637|        signal_doc = {
638|            'coin_id': signal['coin_id'],
639|            'symbol': signal['symbol'],
640|            'timeframe': signal['timeframe'],
641|            'direction': signal['direction'],
642|            'entry_price': signal['entry_price'],
643|            'stop_loss': signal['stop_loss'],
644|            'targets': signal['targets'],
645|            'leverage': signal['leverage'],
646|            'message_id': message_id,
647|            'status': 'ACTIVE',
648|            'targets_hit': [],
649|            'created_at': datetime.now(timezone.utc).isoformat()
650|        }
651|        
652|        self.active_trades_cache[signal['coin_id']] = signal_doc
653|        logger.info(f"âœ… Signal cached: {signal['symbol']} {signal['direction']}")
654|    
655|    async def update_trade_status(self, coin_id: str, status: str, hit_target: Optional[int] = None):
656|        """Update trade status in cache"""
657|        if coin_id in self.active_trades_cache:
658|            if hit_target:
659|                if 'targets_hit' not in self.active_trades_cache[coin_id]:
660|                    self.active_trades_cache[coin_id]['targets_hit'] = []
661|                self.active_trades_cache[coin_id]['targets_hit'].append(hit_target)
662|            else:
663|                self.active_trades_cache[coin_id]['status'] = status
664|    
665|    async def monitor_active_trades(self):
666|        """Monitor active trades and check TP/SL"""
667|        active_trades = await self.check_active_trades()
668|        
669|        if not active_trades:
670|            return
671|        
672|        for coin_id, trade in active_trades.items():
673|            try:
674|                current_price = data_fetcher.get_current_price(coin_id)
675|                
676|                if current_price is None:
677|                    continue
678|                
679|                # Check Stop Loss
680|                if trade['direction'] == 'LONG':
681|                    if current_price <= trade['stop_loss']:
682|                        await self.send_trade_update(trade, 'STOP_LOSS', current_price)
683|                        await self.update_trade_status(coin_id, 'CLOSED_SL')
684|                        if coin_id in self.active_trades_cache:
685|                            del self.active_trades_cache[coin_id]
686|                        continue
687|                    
688|                    # Check Targets
689|                    for i, target in enumerate(trade['targets'], 1):
690|                        if current_price >= target and i not in trade.get('targets_hit', []):
691|                            await self.send_trade_update(trade, f'TARGET_{i}', current_price)
692|                            await self.update_trade_status(coin_id, 'ACTIVE', i)
693|                            
694|                            if i == len(trade['targets']):
695|                                await self.update_trade_status(coin_id, 'CLOSED_TP')
696|                                if coin_id in self.active_trades_cache:
697|                                    del self.active_trades_cache[coin_id]
698|                
699|                else:  # SHORT
700|                    if current_price >= trade['stop_loss']:
701|                        await self.send_trade_update(trade, 'STOP_LOSS', current_price)
702|                        await self.update_trade_status(coin_id, 'CLOSED_SL')
703|                        if coin_id in self.active_trades_cache:
704|                            del self.active_trades_cache[coin_id]
705|                        continue
706|                    
707|                    for i, target in enumerate(trade['targets'], 1):
708|                        if current_price <= target and i not in trade.get('targets_hit', []):
709|                            await self.send_trade_update(trade, f'TARGET_{i}', current_price)
710|                            await self.update_trade_status(coin_id, 'ACTIVE', i)
711|                            
712|                            if i == len(trade['targets']):
713|                                await self.update_trade_status(coin_id, 'CLOSED_TP')
714|                                if coin_id in self.active_trades_cache:
715|                                    del self.active_trades_cache[coin_id]
716|            
717|            except Exception as e:
718|                logger.error(f"âŒ Error monitoring {coin_id}: {e}")
719|    
720|    async def send_trade_update(self, trade: Dict, update_type: str, current_price: float):
721|        """Send trade update to channel"""
722|        try:
723|            coin_id = trade.get('coin_id', '')
724|            coin_data = SYMBOLS.get(coin_id, {})
725|            symbol_name = coin_data.get('name', trade['symbol'])
726|            
727|            if update_type == 'STOP_LOSS':
728|                emoji = "ðŸ›‘"
729|                loss_percent = abs((current_price - trade['entry_price']) / trade['entry_price'] * 100)
730|                message = f"{emoji} *STOP LOSS HIT*\n\n"
731|                message += f"*{symbol_name}* {trade['direction']}\n"
732|                message += f"Entry: `${trade['entry_price']:,.2f}`\n"
733|                message += f"Exit: `${current_price:,.2f}`\n"
734|                message += f"Loss: *-{loss_percent:.2f}%*"
735|            
736|            elif 'TARGET' in update_type:
737|                target_num = int(update_type.split('_')[1])
738|                emoji = "âœ…" if target_num == 1 else "ðŸŽ¯"
739|                
740|                profit_percent = abs((current_price - trade['entry_price']) / trade['entry_price'] * 100)
741|                leverage_profit = profit_percent * trade.get('leverage', 1)
742|                
743|                message = f"{emoji} *TARGET {target_num} HIT*\n\n"
744|                message += f"*{symbol_name}* {trade['direction']}\n"
745|                message += f"Entry: `${trade['entry_price']:,.2f}`\n"
746|                message += f"Target: `${current_price:,.2f}`\n"
747|                message += f"Profit: *+{profit_percent:.2f}%*\n"
748|                message += f"With {trade.get('leverage', 1)}x: *+{leverage_profit:.2f}%*"
749|                
750|                if target_num == len(trade['targets']):
751|                    message += f"\n\nðŸŽ‰ *ALL TARGETS HIT!*"
752|            
753|            await self.bot.send_message(
754|                chat_id=CHANNEL_ID,
755|                text=message,
756|                parse_mode='Markdown',
757|                reply_to_message_id=trade['message_id']
758|            )
759|            
760|            logger.info(f"âœ… Update sent: {symbol_name} - {update_type}")
761|            
762|        except Exception as e:
763|            logger.error(f"âŒ Error sending update: {e}")
764|    
765|    async def send_signal(self, signal: Dict):
766|        """Send signal to Telegram channel - Simplified format"""
767|        try:
768|            chart_buffer = self.chart_gen.create_chart(signal)
769|            
770|            if not chart_buffer:
771|                return
772|            
773|            coin_data = SYMBOLS.get(signal['coin_id'])
774|            symbol_name = coin_data['name'] if coin_data else signal['symbol']
775|            
776|            direction_emoji = "ðŸŸ¢" if signal['direction'] == 'LONG' else "ðŸ”´"
777|            
778|            rr_ratio = signal.get('rr_ratio', 2.0)
779|            potential_profit = abs(signal['targets'][0] - signal['entry_price']) / signal['entry_price'] * 100
780|            
781|            # Simplified message with proper price formatting
782|            message = f"{direction_emoji} *{signal['direction']}* | {symbol_name} | {signal['timeframe'].upper()}\n\n"
783|            
784|            message += f"ðŸ“ *Entry:* `${signal['entry_price']:,.2f}`\n\n"
785|            
786|            message += f"ðŸŽ¯ *Targets:*\n"
787|            for i, target in enumerate(signal['targets'], 1):
788|                message += f"TP{i}: `${target:,.2f}`\n"
789|            
790|            message += f"\nðŸ›‘ *Stop Loss:* `${signal['stop_loss']:,.2f}`\n\n"
791|            
792|            message += f"âš–ï¸ Risk/Reward: `1:{rr_ratio:.1f}`\n"
793|            message += f"ðŸ“Š Leverage: `{signal['leverage']}x`\n"
794|            message += f"ðŸ’¹ Potential: `+{potential_profit:.1f}%+`"
795|            
796|            sent_message = await self.bot.send_photo(
797|                chat_id=CHANNEL_ID,
798|                photo=chart_buffer,
799|                caption=message,
800|                parse_mode='Markdown'
801|            )
802|            
803|            await self.save_signal(signal, sent_message.message_id)
804|            
805|            logger.info(f"âœ… Signal sent: {symbol_name} {signal['direction']}")
806|            
807|        except TelegramError as e:
808|            logger.error(f"âŒ Telegram error: {e}")
809|        except Exception as e:
810|            logger.error(f"âŒ Error sending signal: {e}")
811|    
812|    async def scan_markets(self):
813|        """Scan markets for trading opportunities"""
814|        logger.info("ðŸ” Scanning markets...")
815|        
816|        active_trades = await self.check_active_trades()
817|        signals_found = 0
818|        
819|        for coin_id in SYMBOLS.keys():
820|            if coin_id in active_trades:
821|                continue
822|            
823|            for timeframe in TIMEFRAMES:
824|                try:
825|                    logger.info(f"ðŸ”Ž Analyzing {coin_id} {timeframe}...")
826|                    signal = self.analyzer.generate_signal(coin_id, timeframe)
827|                    
828|                    if signal:
829|                        logger.info(f"âœ… SIGNAL FOUND: {coin_id} {timeframe} {signal['direction']}")
830|                        await self.send_signal(signal)
831|                        signals_found += 1
832|                        break
833|                    
834|                    await asyncio.sleep(2)
835|                    
836|                except Exception as e:
837|                    logger.error(f"âŒ Error scanning {coin_id} {timeframe}: {e}")
838|                    continue
839|        
840|        logger.info(f"âœ… Scan completed. Signals: {signals_found}")
841|    
842|    async def run(self):
843|        """Run the bot"""
844|        logger.info("=" * 60)
845|        logger.info("ðŸ¤– Crypto Signal Bot Starting...")
846|        logger.info("ðŸ“Š Strategy: Smart Money Concept")
847|        logger.info("=" * 60)
848|        
849|        try:
850|            me = await self.bot.get_me()
851|            logger.info(f"âœ… Bot connected: @{me.username}")
852|            logger.info(f"ðŸ“¢ Channel: {CHANNEL_ID}")
853|        except Exception as e:
854|            logger.error(f"âŒ Connection failed: {e}")
855|            return
856|        
857|        logger.info("=" * 60)
858|        logger.info("ðŸš€ Bot running... Press Ctrl+C to stop")
859|        logger.info("=" * 60)
860|        
861|        while True:
862|            try:
863|                await self.scan_markets()
864|                await self.monitor_active_trades()
865|                
866|                logger.info("â¸ï¸ Waiting 5 minutes...")
867|                await asyncio.sleep(300)
868|                
869|            except KeyboardInterrupt:
870|                logger.info("ðŸ›‘ Bot stopped")
871|                break
872|            except Exception as e:
873|                logger.error(f"âš ï¸ Error: {e}")
874|                await asyncio.sleep(60)
875|
876|
877|async def main():
878|    """Main function"""
879|    bot = TelegramSignalBot()
880|    await bot.run()
881|
882|
883|if __name__ == "__main__":
884|    try:
885|        asyncio.run(main())
886|    except KeyboardInterrupt:
887|        logger.info("ðŸ‘‹ Shutdown complete")
888|    except Exception as e:
889|        logger.error(f"âŒ Fatal error: {e}")
890|
