
Action: file_editor view /app/telegram_bot.py
Observation: /app/telegram_bot.py:
1|import os
2|import asyncio
3|import logging
4|from datetime import datetime, timezone, timedelta
5|from typing import Dict, List, Optional, Tuple
6|import numpy as np
7|import pandas as pd
8|import matplotlib
9|matplotlib.use('Agg')
10|import matplotlib.pyplot as plt
11|from matplotlib.patches import Rectangle
12|import io
13|import requests
14|from telegram import Bot
15|from telegram.error import TelegramError
16|from dotenv import load_dotenv
17|from pathlib import Path
18|import time
19|
20|# Load environment variables
21|ROOT_DIR = Path(__file__).parent
22|load_dotenv(ROOT_DIR / '.env')
23|
24|# Configure logging
25|logging.basicConfig(
26|    level=logging.INFO,
27|    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
28|)
29|logger = logging.getLogger(__name__)
30|
31|# Bot Configuration - Load from environment variables
32|BOT_TOKEN = os.environ.get('BOT_TOKEN')
33|CHANNEL_ID = os.environ.get('CHANNEL_ID')
34|
35|if not BOT_TOKEN or not CHANNEL_ID:
36|    raise ValueError("âŒ BOT_TOKEN and CHANNEL_ID must be set in environment variables (.env file)")
37|
38|logger.info(f"âœ… Bot Token loaded: {BOT_TOKEN[:10]}...")
39|logger.info(f"âœ… Channel ID: {CHANNEL_ID}")
40|
41|# MongoDB connection (Optional)
42|mongo_url = os.environ.get('MONGO_URL')
43|USE_DATABASE = bool(mongo_url and mongo_url.strip())
44|
45|if USE_DATABASE:
46|    try:
47|        from motor.motor_asyncio import AsyncIOMotorClient
48|        client = AsyncIOMotorClient(mongo_url)
49|        db = client[os.environ.get('DB_NAME', 'crypto_signals_db')]
50|        logger.info("âœ… MongoDB enabled - trades will be tracked")
51|    except Exception as e:
52|        logger.warning(f"âš ï¸ MongoDB connection failed: {e}")
53|        logger.warning("âš ï¸ Continuing without database...")
54|        USE_DATABASE = False
55|        client = None
56|        db = None
57|else:
58|    client = None
59|    db = None
60|    logger.info("âš ï¸ MongoDB disabled - running without database (signals only)")
61|
62|# Trading pairs to monitor (format Ø¨Ø±Ø§ÛŒ CoinGecko)
63|SYMBOLS = {
64|    'bitcoin': {'name': 'Bitcoin', 'ticker': 'BTC'},
65|    'ethereum': {'name': 'Ethereum', 'ticker': 'ETH'},
66|    'shiba-inu': {'name': 'Shiba Inu', 'ticker': 'SHIB'},
67|    'cardano': {'name': 'Cardano', 'ticker': 'ADA'},
68|    'the-open-network': {'name': 'Toncoin', 'ticker': 'TON'},
69|    'solana': {'name': 'Solana', 'ticker': 'SOL'},
70|    'binancecoin': {'name': 'BNB', 'ticker': 'BNB'}
71|}
72|
73|TIMEFRAMES = ['15m', '1h']
74|
75|# ØªØ¨Ø¯ÛŒÙ„ timeframe Ø¨Ù‡ Ø«Ø§Ù†ÛŒÙ‡
76|TIMEFRAME_SECONDS = {
77|    '15m': 900,
78|    '1h': 3600
79|}
80|
81|
82|class CryptoDataFetcher:
83|    """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø±ÛŒÙ¾ØªÙˆ Ø§Ø² CryptoCompare"""
84|    
85|    def __init__(self):
86|        self.base_url = "https://min-api.cryptocompare.com/data"
87|        self.session = requests.Session()
88|        self.api_key = os.environ.get('CRYPTOCOMPARE_API_KEY', '')
89|        
90|        if self.api_key:
91|            logger.info("âœ… CryptoCompare API key loaded")
92|        else:
93|            logger.info("âš ï¸ No CryptoCompare API key - using free tier (limited)")
94|        
95|    def get_ohlcv(self, coin_id: str, timeframe: str, limit: int = 200) -> pd.DataFrame:
96|        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ OHLCV Ø§Ø² CryptoCompare"""
97|        try:
98|            # ØªØ¨Ø¯ÛŒÙ„ coin_id Ø¨Ù‡ ticker symbol
99|            ticker = SYMBOLS[coin_id]['ticker']
100|            
101|            # Ø§Ù†ØªØ®Ø§Ø¨ endpoint Ø¨Ø± Ø§Ø³Ø§Ø³ timeframe
102|            # CryptoCompare Ù…Ø­Ø¯ÙˆØ¯ÛŒØª limit = 2000 Ø¯Ø§Ø±Ø¯
103|            if timeframe == '15m':
104|                endpoint = f"{self.base_url}/v2/histominute"
105|                actual_limit = min(limit * 15, 2000)
106|                params = {
107|                    'fsym': ticker,
108|                    'tsym': 'USDT',
109|                    'limit': actual_limit,
110|                    'aggregate': 15
111|                }
112|            else:  # 1h
113|                endpoint = f"{self.base_url}/v2/histohour"
114|                actual_limit = min(limit, 2000)
115|                params = {
116|                    'fsym': ticker,
117|                    'tsym': 'USDT',
118|                    'limit': actual_limit
119|                }
120|            
121|            # Add API key if available
122|            if self.api_key:
123|                params['api_key'] = self.api_key
124|            
125|            response = self.session.get(endpoint, params=params, timeout=15)
126|            response.raise_for_status()
127|            data = response.json()
128|            
129|            if data.get('Response') == 'Error':
130|                logger.error(f"Ø®Ø·Ø§ÛŒ API: {data.get('Message')}")
131|                return None
132|            
133|            if 'Data' not in data or 'Data' not in data['Data']:
134|                return None
135|            
136|            # ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ DataFrame
137|            ohlcv_data = data['Data']['Data']
138|            df = pd.DataFrame(ohlcv_data)
139|            
140|            if df.empty:
141|                return None
142|            
143|            # Ø§Ù†ØªØ®Ø§Ø¨ Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ùˆ ØªØºÛŒÛŒØ± Ù†Ø§Ù…
144|            df = df[['time', 'open', 'high', 'low', 'close', 'volumeto']].copy()
145|            df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
146|            
147|            # ØªØ¨Ø¯ÛŒÙ„ timestamp Ø¨Ù‡ datetime
148|            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s')
149|            
150|            # Ø­Ø°Ù Ø±Ø¯ÛŒÙâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± ØµÙØ±
151|            df = df[(df['open'] > 0) & (df['high'] > 0) & (df['low'] > 0) & (df['close'] > 0)]
152|            
153|            return df.reset_index(drop=True)
154|            
155|        except requests.exceptions.Timeout:
156|            logger.error(f"â±ï¸ Timeout fetching data for {coin_id}")
157|            return None
158|        except requests.exceptions.RequestException as e:
159|            logger.error(f"ğŸŒ Network error for {coin_id}: {e}")
160|            return None
161|        except Exception as e:
162|            logger.error(f"âŒ Error fetching data for {coin_id}: {e}")
163|            return None
164|    
165|    def get_current_price(self, coin_id: str) -> float:
166|        """Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ"""
167|        try:
168|            ticker = SYMBOLS[coin_id]['ticker']
169|            url = f"{self.base_url}/price"
170|            params = {
171|                'fsym': ticker,
172|                'tsyms': 'USDT'
173|            }
174|            
175|            if self.api_key:
176|                params['api_key'] = self.api_key
177|            
178|            response = self.session.get(url, params=params, timeout=10)
179|            response.raise_for_status()
180|            data = response.json()
181|            
182|            return data.get('USDT')
183|            
184|        except Exception as e:
185|            logger.error(f"âŒ Error fetching price for {coin_id}: {e}")
186|            return None
187|
188|
189|# Ø³Ø§Ø®Øª Ù†Ù…ÙˆÙ†Ù‡ fetcher
190|data_fetcher = CryptoDataFetcher()
191|
192|
193|class SmartMoneyAnalyzer:
194|    """ØªØ­Ù„ÛŒÙ„Ú¯Ø± Smart Money Concept"""
195|    
196|    def __init__(self):
197|        self.lookback_periods = 50
198|        self.min_rr_ratio = 2.0  # Minimum Risk/Reward ratio
199|        self.volume_threshold = 1.5  # Volume must be 1.5x average
200|        
201|    def detect_swing_points(self, df: pd.DataFrame) -> Tuple[List, List]:
202|        """Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Swing High Ùˆ Swing Low"""
203|        swing_highs = []
204|        swing_lows = []
205|        
206|        for i in range(2, len(df) - 2):
207|            # Swing High: Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø² 2 Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ Ùˆ 2 Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯
208|            if (df['high'].iloc[i] > df['high'].iloc[i-1] and 
209|                df['high'].iloc[i] > df['high'].iloc[i-2] and
210|                df['high'].iloc[i] > df['high'].iloc[i+1] and 
211|                df['high'].iloc[i] > df['high'].iloc[i+2]):
212|                swing_highs.append({
213|                    'index': i,
214|                    'price': df['high'].iloc[i],
215|                    'time': df.index[i]
216|                })
217|            
218|            # Swing Low: Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² 2 Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ Ùˆ 2 Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯
219|            if (df['low'].iloc[i] < df['low'].iloc[i-1] and 
220|                df['low'].iloc[i] < df['low'].iloc[i-2] and
221|                df['low'].iloc[i] < df['low'].iloc[i+1] and 
222|                df['low'].iloc[i] < df['low'].iloc[i+2]):
223|                swing_lows.append({
224|                    'index': i,
225|                    'price': df['low'].iloc[i],
226|                    'time': df.index[i]
227|                })
228|        
229|        return swing_highs, swing_lows
230|    
231|    def detect_bos_choch(self, df: pd.DataFrame, swing_highs: List, swing_lows: List) -> Dict:
232|        """Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Break of Structure (BOS) Ùˆ Change of Character (CHoCH)"""
233|        if len(swing_highs) < 2 or len(swing_lows) < 2:
234|            return None
235|        
236|        last_swing_high = swing_highs[-1]['price']
237|        last_swing_low = swing_lows[-1]['price']
238|        current_price = df['close'].iloc[-1]
239|        
240|        # BOS Bullish: Ø´Ú©Ø³Øª Ø¢Ø®Ø±ÛŒÙ† swing high
241|        if current_price > last_swing_high:
242|            return {
243|                'type': 'BOS_BULLISH',
244|                'signal': 'LONG',
245|                'level': last_swing_high
246|            }
247|        
248|        # BOS Bearish: Ø´Ú©Ø³Øª Ø¢Ø®Ø±ÛŒÙ† swing low
249|        if current_price < last_swing_low:
250|            return {
251|                'type': 'BOS_BEARISH',
252|                'signal': 'SHORT',
253|                'level': last_swing_low
254|            }
255|        
256|        return None
257|    
258|    def detect_order_blocks(self, df: pd.DataFrame, signal_type: str) -> Optional[Dict]:
259|        """Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Order Blocks"""
260|        order_blocks = []
261|        
262|        for i in range(len(df) - 10, len(df) - 1):
263|            candle = df.iloc[i]
264|            next_candle = df.iloc[i + 1]
265|            
266|            # Bullish Order Block
267|            if signal_type == 'LONG':
268|                # Ø¢Ø®Ø±ÛŒÙ† Ú©Ù†Ø¯Ù„ Ù†Ø²ÙˆÙ„ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø­Ø±Ú©Øª ØµØ¹ÙˆØ¯ÛŒ Ù‚ÙˆÛŒ
269|                if (candle['close'] < candle['open'] and 
270|                    next_candle['close'] > next_candle['open'] and
271|                    (next_candle['close'] - next_candle['open']) > 2 * abs(candle['close'] - candle['open'])):
272|                    order_blocks.append({
273|                        'type': 'BULLISH_OB',
274|                        'high': candle['high'],
275|                        'low': candle['low'],
276|                        'index': i
277|                    })
278|            
279|            # Bearish Order Block
280|            elif signal_type == 'SHORT':
281|                # Ø¢Ø®Ø±ÛŒÙ† Ú©Ù†Ø¯Ù„ ØµØ¹ÙˆØ¯ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø­Ø±Ú©Øª Ù†Ø²ÙˆÙ„ÛŒ Ù‚ÙˆÛŒ
282|                if (candle['close'] > candle['open'] and 
283|                    next_candle['close'] < next_candle['open'] and
284|                    (next_candle['open'] - next_candle['close']) > 2 * abs(candle['close'] - candle['open'])):
285|                    order_blocks.append({
286|                        'type': 'BEARISH_OB',
287|                        'high': candle['high'],
288|                        'low': candle['low'],
289|                        'index': i
290|                    })
291|        
292|        return order_blocks[-1] if order_blocks else None
293|    
294|    def detect_fvg(self, df: pd.DataFrame) -> List[Dict]:
295|        """Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Fair Value Gaps (FVG)"""
296|        fvgs = []
297|        
298|        for i in range(1, len(df) - 1):
299|            prev_candle = df.iloc[i - 1]
300|            current_candle = df.iloc[i]
301|            next_candle = df.iloc[i + 1]
302|            
303|            # Bullish FVG: Ú¯Ù¾ Ø¨ÛŒÙ† low Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯ÛŒ Ùˆ high Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ÛŒ
304|            if next_candle['low'] > prev_candle['high']:
305|                fvgs.append({
306|                    'type': 'BULLISH_FVG',
307|                    'top': next_candle['low'],
308|                    'bottom': prev_candle['high'],
309|                    'index': i
310|                })
311|            
312|            # Bearish FVG: Ú¯Ù¾ Ø¨ÛŒÙ† high Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯ÛŒ Ùˆ low Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ÛŒ
313|            if next_candle['high'] < prev_candle['low']:
314|                fvgs.append({
315|                    'type': 'BEARISH_FVG',
316|                    'top': prev_candle['low'],
317|                    'bottom': next_candle['high'],
318|                    'index': i
319|                })
320|        
321|        # ÙÙ‚Ø· Ø¢Ø®Ø±ÛŒÙ† FVG Ù‡Ø§ Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†
322|        return fvgs[-3:] if fvgs else []
323|    
324|    def calculate_premium_discount(self, df: pd.DataFrame, swing_highs: List, swing_lows: List) -> Dict:
325|        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Premium Ùˆ Discount Zone"""
326|        if not swing_highs or not swing_lows:
327|            return None
328|        
329|        recent_high = max([sh['price'] for sh in swing_highs[-3:]])
330|        recent_low = min([sl['price'] for sl in swing_lows[-3:]])
331|        
332|        range_size = recent_high - recent_low
333|        current_price = df['close'].iloc[-1]
334|        
335|        # Premium zone: 50% - 100% of range
336|        premium_threshold = recent_low + (range_size * 0.5)
337|        
338|        # Discount zone: 0% - 50% of range
339|        discount_threshold = recent_low + (range_size * 0.5)
340|        
341|        equilibrium = recent_low + (range_size * 0.5)
342|        
343|        if current_price >= premium_threshold:
344|            zone = 'PREMIUM'
345|        elif current_price <= discount_threshold:
346|            zone = 'DISCOUNT'
347|        else:
348|            zone = 'EQUILIBRIUM'
349|        
350|        return {
351|            'zone': zone,
352|            'high': recent_high,
353|            'low': recent_low,
354|            'equilibrium': equilibrium,
355|            'current': current_price
356|        }
357|    
358|    def calculate_ema(self, df: pd.DataFrame, period: int) -> pd.Series:
359|        """Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ ØªØ±Ù†Ø¯"""
360|        return df['close'].ewm(span=period, adjust=False).mean()
361|    
362|    def calculate_atr(self, df: pd.DataFrame, period: int = 14) -> float:
363|        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Average True Range"""
364|        high_low = df['high'] - df['low']
365|        high_close = np.abs(df['high'] - df['close'].shift())
366|        low_close = np.abs(df['low'] - df['close'].shift())
367|        
368|        ranges = pd.concat([high_low, high_close, low_close], axis=1)
369|        true_range = np.max(ranges, axis=1)
370|        atr = true_range.rolling(period).mean().iloc[-1]
371|        
372|        return atr
373|    
374|    def check_volume_confirmation(self, df: pd.DataFrame) -> bool:
375|        """ØªØ£ÛŒÛŒØ¯ Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª"""
376|        if len(df) < 20:
377|            return False
378|        
379|        avg_volume = df['volume'].tail(20).mean()
380|        recent_volume = df['volume'].tail(5).mean()
381|        
382|        # Ø­Ø¬Ù… Ø¨Ø§ÛŒØ¯ 1.5 Ø¨Ø±Ø§Ø¨Ø± Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¨Ø§Ø´Ø¯
383|        return recent_volume >= (avg_volume * self.volume_threshold)
384|    
385|    def check_trend_alignment(self, df: pd.DataFrame, signal_direction: str) -> bool:
386|        """ØªØ£ÛŒÛŒØ¯ Ù‡Ù…Ø³ÙˆÛŒÛŒ Ø¨Ø§ ØªØ±Ù†Ø¯ Ø§ØµÙ„ÛŒ"""
387|        ema_20 = self.calculate_ema(df, 20)
388|        ema_50 = self.calculate_ema(df, 50)
389|        
390|        current_price = df['close'].iloc[-1]
391|        
392|        if signal_direction == 'LONG':
393|            # Ø¨Ø±Ø§ÛŒ Long: EMA20 > EMA50 Ùˆ Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ÛŒ EMA20
394|            return ema_20.iloc[-1] > ema_50.iloc[-1] and current_price > ema_20.iloc[-1]
395|        else:  # SHORT
396|            # Ø¨Ø±Ø§ÛŒ Short: EMA20 < EMA50 Ùˆ Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÛŒÙ† EMA20
397|            return ema_20.iloc[-1] < ema_50.iloc[-1] and current_price < ema_20.iloc[-1]
398|    
399|    def generate_signal(self, coin_id: str, timeframe: str) -> Optional[Dict]:
400|        """ØªÙˆÙ„ÛŒØ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø§ ÙÛŒÙ„ØªØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡"""
401|        try:
402|            # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚ÛŒÙ…ØªÛŒ
403|            df = data_fetcher.get_ohlcv(coin_id, timeframe, limit=150)
404|            
405|            if df is None or len(df) < 60:
406|                return None
407|            
408|            df.set_index('timestamp', inplace=True)
409|            
410|            # ØªØ­Ù„ÛŒÙ„ Smart Money
411|            swing_highs, swing_lows = self.detect_swing_points(df)
412|            
413|            if len(swing_highs) < 3 or len(swing_lows) < 3:
414|                return None
415|            
416|            # Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ BOS/CHoCH
417|            structure = self.detect_bos_choch(df, swing_highs, swing_lows)
418|            
419|            if not structure:
420|                return None
421|            
422|            # ØªØ£ÛŒÛŒØ¯ Volume
423|            volume_confirmed = self.check_volume_confirmation(df)
424|            if not volume_confirmed:
425|                logger.info(f"{coin_id}: Volume confirmation failed")
426|                return None
427|            
428|            # ØªØ£ÛŒÛŒØ¯ Trend
429|            trend_aligned = self.check_trend_alignment(df, structure['signal'])
430|            if not trend_aligned:
431|                logger.info(f"{coin_id}: Trend alignment failed")
432|                return None
433|            
434|            # Order Blocks
435|            order_block = self.detect_order_blocks(df, structure['signal'])
436|            if not order_block:
437|                logger.info(f"{coin_id}: No valid Order Block found")
438|                return None
439|            
440|            # Fair Value Gaps
441|            fvgs = self.detect_fvg(df)
442|            
443|            # Premium/Discount Zone
444|            pd_zone = self.calculate_premium_discount(df, swing_highs, swing_lows)
445|            
446|            current_price = df['close'].iloc[-1]
447|            atr = self.calculate_atr(df)
448|            
449|            # Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± Ú†Ø§Ø±Øª
450|            ema_20 = self.calculate_ema(df, 20)
451|            ema_50 = self.calculate_ema(df, 50)
452|            
453|            # Ø´Ø±Ø§ÛŒØ· ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡
454|            valid_signal = False
455|            
456|            if structure['signal'] == 'LONG':
457|                # Ø¨Ø±Ø§ÛŒ Long: Ø¨Ø§ÛŒØ¯ Ø¯Ø± Discount Zone Ø¨Ø§Ø´ÛŒÙ…
458|                if pd_zone and pd_zone['zone'] == 'DISCOUNT':
459|                    valid_signal = True
460|                    entry_price = current_price
461|                    stop_loss = order_block['low'] - (atr * 0.5)  # ATR-based SL
462|                    risk = entry_price - stop_loss
463|                    
464|                    # Targets Ø¨Ø§ Ù†Ø³Ø¨Øª 2:1, 3:1, 4:1
465|                    target1 = entry_price + (risk * 2.0)
466|                    target2 = entry_price + (risk * 3.0)
467|                    target3 = entry_price + (risk * 4.0)
468|            
469|            elif structure['signal'] == 'SHORT':
470|                # Ø¨Ø±Ø§ÛŒ Short: Ø¨Ø§ÛŒØ¯ Ø¯Ø± Premium Zone Ø¨Ø§Ø´ÛŒÙ…
471|                if pd_zone and pd_zone['zone'] == 'PREMIUM':
472|                    valid_signal = True
473|                    entry_price = current_price
474|                    stop_loss = order_block['high'] + (atr * 0.5)  # ATR-based SL
475|                    risk = stop_loss - entry_price
476|                    
477|                    # Targets Ø¨Ø§ Ù†Ø³Ø¨Øª 2:1, 3:1, 4:1
478|                    target1 = entry_price - (risk * 2.0)
479|                    target2 = entry_price - (risk * 3.0)
480|                    target3 = entry_price - (risk * 4.0)
481|            
482|            if not valid_signal:
483|                return None
484|            
485|            # Ø¨Ø±Ø±Ø³ÛŒ Ø­Ø¯Ø§Ù‚Ù„ R/R
486|            rr_ratio = abs(target1 - entry_price) / risk
487|            if rr_ratio < self.min_rr_ratio:
488|                logger.info(f"{coin_id}: R/R ratio too low ({rr_ratio:.2f})")
489|                return None
490|            
491|            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù„ÙˆØ±ÛŒØ¬ Ù…Ø­Ø§ÙØ¸Ù‡â€ŒÚ©Ø§Ø±Ø§Ù†Ù‡
492|            risk_percent = (risk / entry_price) * 100
493|            if risk_percent < 1.5:
494|                leverage = 10
495|            elif risk_percent < 2.5:
496|                leverage = 7
497|            elif risk_percent < 4:
498|                leverage = 5
499|            else:
500|                leverage = 3
501|            
502|            signal = {
503|                'coin_id': coin_id,
504|                'symbol': SYMBOLS[coin_id]['ticker'] + '/USDT',
505|                'timeframe': timeframe,
506|                'direction': structure['signal'],
507|                'entry_price': round(entry_price, 8),
508|                'stop_loss': round(stop_loss, 8),
509|                'targets': [
510|                    round(target1, 8),
511|                    round(target2, 8),
512|                    round(target3, 8)
513|                ],
514|                'leverage': leverage,
515|                'structure_type': structure['type'],
516|                'order_block': order_block,
517|                'fvgs': fvgs,
518|                'pd_zone': pd_zone,
519|                'df': df,
520|                'swing_highs': swing_highs,
521|                'swing_lows': swing_lows,
522|                'ema_20': ema_20,
523|                'ema_50': ema_50,
524|                'atr': atr,
525|                'rr_ratio': rr_ratio,
526|                'timestamp': datetime.now(timezone.utc)
527|            }
528|            
529|            return signal
530|            
531|        except Exception as e:
532|            logger.error(f"âŒ Error generating signal for {coin_id}: {e}")
533|            return None
534|
535|
536|class ChartGenerator:
537|    """ØªÙˆÙ„ÛŒØ¯ Ú†Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ ØªØ­Ù„ÛŒÙ„ÛŒ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ"""
538|    
539|    @staticmethod
540|    def create_chart(signal: Dict) -> io.BytesIO:
541|        """Ø³Ø§Ø®Øª Ú†Ø§Ø±Øª Ú©Ù†Ø¯Ù„ÛŒ Ø¨Ø§ ØªØ­Ù„ÛŒÙ„ SMC - TradingView Style"""
542|        try:
543|            df = signal['df'].tail(100)  # Ø¢Ø®Ø±ÛŒÙ† 100 Ú©Ù†Ø¯Ù„
544|            
545|            # TradingView style: background Ø³ÙÛŒØ¯
546|            fig, ax = plt.subplots(figsize=(20, 12))
547|            fig.patch.set_facecolor('#ffffff')
548|            ax.set_facecolor('#ffffff')
549|            
550|            # Ø±Ø³Ù… EMA Ù‡Ø§
551|            if 'ema_20' in signal and 'ema_50' in signal:
552|                ema_20_values = signal['ema_20'].tail(100).values
553|                ema_50_values = signal['ema_50'].tail(100).values
554|                
555|                ax.plot(range(len(ema_20_values)), ema_20_values, 
556|                       color='#2962FF', linewidth=2, label='EMA 20', alpha=0.8, zorder=2)
557|                ax.plot(range(len(ema_50_values)), ema_50_values, 
558|                       color='#FF6D00', linewidth=2, label='EMA 50', alpha=0.8, zorder=2)
559|            
560|            # Ø±Ø³Ù… Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ - TradingView colors
561|            for idx in range(len(df)):
562|                row = df.iloc[idx]
563|                
564|                # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø¹ØªØ¨Ø± Ù‡Ø³ØªÙ†Ø¯
565|                if pd.isna(row['open']) or pd.isna(row['close']) or pd.isna(row['high']) or pd.isna(row['low']):
566|                    continue
567|                
568|                # TradingView default colors
569|                is_bullish = row['close'] >= row['open']
570|                candle_color = '#089981' if is_bullish else '#F23645'
571|                wick_color = '#089981' if is_bullish else '#F23645'
572|                
573|                # Ø¨Ø¯Ù†Ù‡ Ú©Ù†Ø¯Ù„
574|                height = abs(row['close'] - row['open'])
575|                if height == 0:
576|                    height = 0.0001  # Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø®Ø·Ø§
577|                bottom = min(row['open'], row['close'])
578|                
579|                ax.add_patch(Rectangle((idx - 0.4, bottom), 0.8, height, 
580|                                       facecolor=candle_color, edgecolor=candle_color, 
581|                                       alpha=0.9, linewidth=1, zorder=3))
582|                
583|                # Ø³Ø§ÛŒÙ‡ Ú©Ù†Ø¯Ù„
584|                ax.plot([idx, idx], [row['low'], row['high']], 
585|                       color=wick_color, linewidth=1.5, alpha=0.8, zorder=2)
586|            
587|            # Ø±Ø³Ù… Premium/Discount Zones
588|            if signal.get('pd_zone'):
589|                pd_zone = signal['pd_zone']
590|                ax.axhspan(pd_zone['equilibrium'], pd_zone['high'], 
591|                          alpha=0.08, color='#F23645', label='Premium Zone', zorder=0)
592|                ax.axhspan(pd_zone['low'], pd_zone['equilibrium'], 
593|                          alpha=0.08, color='#089981', label='Discount Zone', zorder=0)
594|                ax.axhline(pd_zone['equilibrium'], color='#787B86', 
595|                          linestyle='--', linewidth=1.5, alpha=0.7, label='Equilibrium', zorder=1)
596|            
597|            # Ø±Ø³Ù… Order Block Ø¨Ø§ label
598|            if signal.get('order_block'):
599|                ob = signal['order_block']
600|                ob_color = '#089981' if signal['direction'] == 'LONG' else '#F23645'
601|                ax.axhspan(ob['low'], ob['high'], alpha=0.25, color=ob_color, 
602|                          label='Order Block', zorder=1, edgecolor=ob_color, linewidth=2)
603|                
604|                # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† text label Ø¨Ø±Ø§ÛŒ Order Block
605|                mid_price = (ob['low'] + ob['high']) / 2
606|                ax.text(len(df) - 15, mid_price, 'OB', 
607|                       fontsize=12, fontweight='bold', color=ob_color,
608|                       bbox=dict(boxstyle='round,pad=0.5', facecolor='white', 
609|                                edgecolor=ob_color, linewidth=2), zorder=4)
610|            
611|            # Ø±Ø³Ù… Fair Value Gaps
612|            for i, fvg in enumerate(signal.get('fvgs', [])):
613|                fvg_color = '#2962FF' if 'BULLISH' in fvg['type'] else '#FF6D00'
614|                ax.axhspan(fvg['bottom'], fvg['top'], alpha=0.15, 
615|                          color=fvg_color, zorder=1, linestyle='--', 
616|                          edgecolor=fvg_color, linewidth=1)
617|            
618|            # Ø±Ø³Ù… Swing Points
619|            for sh in signal.get('swing_highs', [])[-8:]:
620|                if sh['index'] < len(df):
621|                    ax.plot(sh['index'], sh['price'], 'v', 
622|                           color='#F23645', markersize=10, markeredgecolor='white', 
623|                           markeredgewidth=1.5, zorder=4)
624|            
625|            for sl in signal.get('swing_lows', [])[-8:]:
626|                if sl['index'] < len(df):
627|                    ax.plot(sl['index'], sl['price'], '^', 
628|                           color='#089981', markersize=10, markeredgecolor='white',
629|                           markeredgewidth=1.5, zorder=4)
630|            
631|            # Ù†Ù‚Ø·Ù‡ ÙˆØ±ÙˆØ¯ - Ø¨Ø²Ø±Ú¯ØªØ± Ùˆ ÙˆØ§Ø¶Ø­â€ŒØªØ±
632|            entry_idx = len(df) - 1
633|            entry_price = signal['entry_price']
634|            entry_color = '#2962FF' if signal['direction'] == 'LONG' else '#F23645'
635|            ax.plot(entry_idx, entry_price, 'D', color=entry_color, markersize=15, 
636|                   markeredgecolor='white', markeredgewidth=2.5, label='ENTRY', zorder=6)
637|            
638|            # Ø®Ø· Entry
639|            ax.axhline(entry_price, color=entry_color, linestyle='-', 
640|                      linewidth=2, alpha=0.5, zorder=1)
641|            
642|            # Stop Loss - Ù‚Ø±Ù…Ø² Ùˆ ÙˆØ§Ø¶Ø­
643|            ax.axhline(signal['stop_loss'], color='#F23645', linestyle='--', 
644|                      linewidth=2.5, label=f"SL: ${signal['stop_loss']:.4f}", alpha=0.9, zorder=2)
645|            
646|            # Targets - Ø³Ø¨Ø² Ùˆ ÙˆØ§Ø¶Ø­
647|            target_colors = ['#26A69A', '#00897B', '#00695C']
648|            for i, target in enumerate(signal['targets']):
649|                ax.axhline(target, color=target_colors[i], linestyle='--', 
650|                          linewidth=2.5, label=f"TP{i+1}: ${target:.4f}", alpha=0.9, zorder=2)
651|                
652|                # Label Ø±ÙˆÛŒ Ø®Ø·
653|                ax.text(len(df) - 5, target, f'TP{i+1}', 
654|                       fontsize=11, fontweight='bold', color=target_colors[i],
655|                       bbox=dict(boxstyle='round,pad=0.4', facecolor='white', 
656|                                edgecolor=target_colors[i], linewidth=2), 
657|                       ha='center', zorder=5)
658|            
659|            # Grid - Ø³Ø¨Ú© TradingView
660|            ax.grid(True, alpha=0.2, color='#E0E3EB', linestyle='-', linewidth=0.5)
661|            ax.set_axisbelow(True)
662|            
663|            # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø­ÙˆØ± - Ø³Ø¨Ú© TradingView
664|            ax.tick_params(colors='#131722', labelsize=11)
665|            for spine in ax.spines.values():
666|                spine.set_color('#E0E3EB')
667|                spine.set_linewidth(1)
668|            
669|            # Ø¹Ù†ÙˆØ§Ù† Ùˆ Ø¨Ø±Ú†Ø³Ø¨â€ŒÙ‡Ø§
670|            direction_emoji = "ğŸŸ¢ LONG" if signal['direction'] == 'LONG' else "ğŸ”´ SHORT"
671|            coin_data = SYMBOLS.get(signal['coin_id'])
672|            title_name = coin_data['name'] if coin_data else signal['symbol']
673|            
674|            # Ø¹Ù†ÙˆØ§Ù† Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ
675|            title = f"{direction_emoji} | {title_name} ({signal['symbol']}) | {signal['timeframe'].upper()}"
676|            subtitle = f"Smart Money Concept Analysis | R/R: 1:{signal.get('rr_ratio', 0):.1f}"
677|            
678|            ax.set_title(title, color='#131722', fontsize=20, fontweight='bold', pad=15)
679|            ax.text(0.5, 1.02, subtitle, transform=ax.transAxes, 
680|                   fontsize=12, ha='center', color='#787B86')
681|            
682|            ax.set_xlabel('Time Period', color='#131722', fontsize=13, fontweight='bold')
683|            ax.set_ylabel('Price (USDT)', color='#131722', fontsize=13, fontweight='bold')
684|            
685|            # Legend - Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ
686|            legend = ax.legend(loc='upper left', fontsize=10, framealpha=0.95, 
687|                              facecolor='white', edgecolor='#E0E3EB', 
688|                              shadow=True, ncol=2)
689|            legend.get_frame().set_linewidth(1.5)
690|            
691|            plt.tight_layout()
692|            
693|            # Ø°Ø®ÛŒØ±Ù‡ Ø¨Ø§ Ú©ÛŒÙÛŒØª Ø¨Ø§Ù„Ø§
694|            buf = io.BytesIO()
695|            plt.savefig(buf, format='png', dpi=150, facecolor='#ffffff', 
696|                       edgecolor='none', bbox_inches='tight')
697|            buf.seek(0)
698|            plt.close()
699|            
700|            return buf
701|            
702|        except Exception as e:
703|            logger.error(f"âŒ Error creating chart: {e}")
704|            # Return a simple error image
705|            fig, ax = plt.subplots(figsize=(10, 6))
706|            ax.text(0.5, 0.5, f'Error creating chart\n{str(e)}', 
707|                   ha='center', va='center', fontsize=14, color='red')
708|            ax.axis('off')
709|            buf = io.BytesIO()
710|            plt.savefig(buf, format='png', dpi=150)
711|            buf.seek(0)
712|            plt.close()
713|            return buf
714|
715|
716|class TelegramSignalBot:
717|    """Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§"""
718|    
719|    def __init__(self):
720|        self.bot = Bot(token=BOT_TOKEN)
721|        self.analyzer = SmartMoneyAnalyzer()
722|        self.chart_gen = ChartGenerator()
723|        self.active_trades_cache = {}  # In-memory cache when DB is disabled
724|        
725|    async def check_active_trades(self) -> Dict[str, Dict]:
726|        """Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙØ¹Ø§Ù„"""
727|        if not USE_DATABASE:
728|            # Use in-memory cache
729|            return self.active_trades_cache
730|        
731|        try:
732|            active_trades = {}
733|            cursor = db.active_signals.find({})
734|            async for trade in cursor:
735|                coin_id = trade.get('coin_id', trade.get('symbol'))
736|                active_trades[coin_id] = trade
737|            return active_trades
738|        except Exception as e:
739|            logger.error(f"âŒ Error checking active trades: {e}")
740|            return {}
741|    
742|    async def save_signal(self, signal: Dict, message_id: int):
743|        """Ø°Ø®ÛŒØ±Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÛŒØ§ cache"""
744|        signal_doc = {
745|            'coin_id': signal['coin_id'],
746|            'symbol': signal['symbol'],
747|            'timeframe': signal['timeframe'],
748|            'direction': signal['direction'],
749|            'entry_price': signal['entry_price'],
750|            'stop_loss': signal['stop_loss'],
751|            'targets': signal['targets'],
752|            'leverage': signal['leverage'],
753|            'message_id': message_id,
754|            'status': 'ACTIVE',
755|            'targets_hit': [],
756|            'created_at': datetime.now(timezone.utc).isoformat()
757|        }
758|        
759|        if USE_DATABASE:
760|            try:
761|                await db.active_signals.insert_one(signal_doc)
762|                logger.info(f"âœ… Signal saved to DB: {signal['symbol']} {signal['direction']}")
763|            except Exception as e:
764|                logger.error(f"âŒ Error saving signal to DB: {e}")
765|                # Fallback to cache
766|                self.active_trades_cache[signal['coin_id']] = signal_doc
767|        else:
768|            # Save to in-memory cache
769|            self.active_trades_cache[signal['coin_id']] = signal_doc
770|            logger.info(f"âœ… Signal cached: {signal['symbol']} {signal['direction']}")
771|    
772|    async def update_trade_status(self, coin_id: str, status: str, hit_target: Optional[int] = None):
773|        """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ù‡"""
774|        if not USE_DATABASE:
775|            # Update in-memory cache
776|            if coin_id in self.active_trades_cache:
777|                if hit_target:
778|                    if 'targets_hit' not in self.active_trades_cache[coin_id]:
779|                        self.active_trades_cache[coin_id]['targets_hit'] = []
780|                    self.active_trades_cache[coin_id]['targets_hit'].append(hit_target)
781|                else:
782|                    self.active_trades_cache[coin_id]['status'] = status
783|            return
784|        
785|        try:
786|            update_data = {'status': status}
787|            
788|            if hit_target:
789|                await db.active_signals.update_one(
790|                    {'coin_id': coin_id, 'status': 'ACTIVE'},
791|                    {'$push': {'targets_hit': hit_target}}
792|                )
793|            else:
794|                await db.active_signals.update_one(
795|                    {'coin_id': coin_id, 'status': 'ACTIVE'},
796|                    {'$set': update_data}
797|                )
798|        except Exception as e:
799|            logger.error(f"âŒ Error updating trade status: {e}")
800|    
801|    async def monitor_active_trades(self):
802|        """Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙØ¹Ø§Ù„ Ùˆ Ú†Ú© Ú©Ø±Ø¯Ù† TP/SL"""
803|        active_trades = await self.check_active_trades()
804|        
805|        if not active_trades:
806|            return
807|        
808|        for coin_id, trade in active_trades.items():
809|            try:
810|                # Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
811|                current_price = data_fetcher.get_current_price(coin_id)
812|                
813|                if current_price is None:
814|                    continue
815|                
816|                # Ø¨Ø±Ø±Ø³ÛŒ Stop Loss
817|                if trade['direction'] == 'LONG':
818|                    if current_price <= trade['stop_loss']:
819|                        await self.send_trade_update(trade, 'STOP_LOSS', current_price)
820|                        await self.update_trade_status(coin_id, 'CLOSED_SL')
821|                        if not USE_DATABASE and coin_id in self.active_trades_cache:
822|                            del self.active_trades_cache[coin_id]
823|                        elif USE_DATABASE:
824|                            await db.active_signals.delete_one({'coin_id': coin_id})
825|                        continue
826|                    
827|                    # Ø¨Ø±Ø±Ø³ÛŒ Targets
828|                    for i, target in enumerate(trade['targets'], 1):
829|                        if current_price >= target and i not in trade.get('targets_hit', []):
830|                            await self.send_trade_update(trade, f'TARGET_{i}', current_price)
831|                            await self.update_trade_status(coin_id, 'ACTIVE', i)
832|                            
833|                            # Ø§Ú¯Ø± Ù‡Ù…Ù‡ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ù‡ÛŒØª Ø´Ø¯
834|                            if i == len(trade['targets']):
835|                                await self.update_trade_status(coin_id, 'CLOSED_TP')
836|                                if not USE_DATABASE and coin_id in self.active_trades_cache:
837|                                    del self.active_trades_cache[coin_id]
838|                                elif USE_DATABASE:
839|                                    await db.active_signals.delete_one({'coin_id': coin_id})
840|                
841|                else:  # SHORT
842|                    if current_price >= trade['stop_loss']:
843|                        await self.send_trade_update(trade, 'STOP_LOSS', current_price)
844|                        await self.update_trade_status(coin_id, 'CLOSED_SL')
845|                        if not USE_DATABASE and coin_id in self.active_trades_cache:
846|                            del self.active_trades_cache[coin_id]
847|                        elif USE_DATABASE:
848|                            await db.active_signals.delete_one({'coin_id': coin_id})
849|                        continue
850|                    
851|                    # Ø¨Ø±Ø±Ø³ÛŒ Targets
852|                    for i, target in enumerate(trade['targets'], 1):
853|                        if current_price <= target and i not in trade.get('targets_hit', []):
854|                            await self.send_trade_update(trade, f'TARGET_{i}', current_price)
855|                            await self.update_trade_status(coin_id, 'ACTIVE', i)
856|                            
857|                            # Ø§Ú¯Ø± Ù‡Ù…Ù‡ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ù‡ÛŒØª Ø´Ø¯
858|                            if i == len(trade['targets']):
859|                                await self.update_trade_status(coin_id, 'CLOSED_TP')
860|                                if not USE_DATABASE and coin_id in self.active_trades_cache:
861|                                    del self.active_trades_cache[coin_id]
862|                                elif USE_DATABASE:
863|                                    await db.active_signals.delete_one({'coin_id': coin_id})
864|            
865|            except Exception as e:
866|                logger.error(f"âŒ Error monitoring {coin_id}: {e}")
867|    
868|    async def send_trade_update(self, trade: Dict, update_type: str, current_price: float):
869|        """Ø§Ø±Ø³Ø§Ù„ Ø¢Ù¾Ø¯ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„ - English & Professional"""
870|        try:
871|            # Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù†Ø§Ù… Ø§Ø±Ø²
872|            coin_id = trade.get('coin_id', '')
873|            coin_data = SYMBOLS.get(coin_id, {})
874|            symbol_name = coin_data.get('name', trade['symbol'])
875|            
876|            if update_type == 'STOP_LOSS':
877|                emoji = "ğŸ›‘"
878|                message = f"{emoji} *STOP LOSS TRIGGERED*\n"
879|                message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
880|                message += f"*{symbol_name}* `{trade['symbol']}`\n"
881|                message += f"Direction: *{trade['direction']}*\n\n"
882|                message += f"Entry Price: `${trade['entry_price']:.6f}`\n"
883|                message += f"Stop Loss: `${trade['stop_loss']:.6f}`\n"
884|                message += f"Exit Price: `${current_price:.6f}`\n\n"
885|                
886|                loss_percent = abs((current_price - trade['entry_price']) / trade['entry_price'] * 100)
887|                message += f"ğŸ“‰ Loss: *-{loss_percent:.2f}%*\n\n"
888|                message += f"âš ï¸ Trade closed at stop loss"
889|            
890|            elif 'TARGET' in update_type:
891|                target_num = int(update_type.split('_')[1])
892|                
893|                if target_num == 1:
894|                    emoji = "âœ…"
895|                elif target_num == 2:
896|                    emoji = "ğŸ’š"
897|                else:
898|                    emoji = "ğŸ¯"
899|                
900|                message = f"{emoji} *TARGET {target_num} REACHED*\n"
901|                message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
902|                message += f"*{symbol_name}* `{trade['symbol']}`\n"
903|                message += f"Direction: *{trade['direction']}*\n\n"
904|                message += f"Entry Price: `${trade['entry_price']:.6f}`\n"
905|                message += f"Target {target_num}: `${trade['targets'][target_num-1]:.6f}`\n"
906|                message += f"Current Price: `${current_price:.6f}`\n\n"
907|                
908|                profit_percent = abs((current_price - trade['entry_price']) / trade['entry_price'] * 100)
909|                leverage_profit = profit_percent * trade.get('leverage', 1)
910|                
911|                message += f"ğŸ“ˆ Profit: *+{profit_percent:.2f}%*\n"
912|                message += f"ğŸ’° With {trade.get('leverage', 1)}x Leverage: *+{leverage_profit:.2f}%*\n\n"
913|                
914|                if target_num == len(trade['targets']):
915|                    message += f"ğŸ‰ *ALL TARGETS HIT!*\n"
916|                    message += f"âœ¨ Trade completed successfully!"
917|                else:
918|                    message += f"â« Moving to next target..."
919|            
920|            # Reply Ø¨Ù‡ Ù¾ÛŒØ§Ù… Ø§ØµÙ„ÛŒ
921|            await self.bot.send_message(
922|                chat_id=CHANNEL_ID,
923|                text=message,
924|                parse_mode='Markdown',
925|                reply_to_message_id=trade['message_id']
926|            )
927|            
928|            logger.info(f"âœ… Update sent: {symbol_name} - {update_type}")
929|            
930|        except Exception as e:
931|            logger.error(f"âŒ Error sending update: {e}")
932|    
933|    async def send_signal(self, signal: Dict):
934|        """Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„ ØªÙ„Ú¯Ø±Ø§Ù… - Professional Format"""
935|        try:
936|            # ØªÙˆÙ„ÛŒØ¯ Ú†Ø§Ø±Øª
937|            chart_buffer = self.chart_gen.create_chart(signal)
938|            
939|            # Ù…ØªÙ† Ù¾ÛŒØ§Ù…
940|            coin_data = SYMBOLS.get(signal['coin_id'])
941|            symbol_name = coin_data['name'] if coin_data else signal['symbol']
942|            
943|            # Direction with emoji
944|            if signal['direction'] == 'LONG':
945|                direction_emoji = "ğŸŸ¢"
946|                direction_text = "LONG"
947|            else:
948|                direction_emoji = "ğŸ”´"
949|                direction_text = "SHORT"
950|            
951|            # Risk/Reward
952|            risk = abs(signal['entry_price'] - signal['stop_loss'])
953|            rr_ratio = signal.get('rr_ratio', 2.0)
954|            
955|            # Ù…Ø­Ø§Ø³Ø¨Ù‡ potential profit
956|            potential_profit_tp1 = abs(signal['targets'][0] - signal['entry_price']) / signal['entry_price'] * 100
957|            potential_profit_tp3 = abs(signal['targets'][2] - signal['entry_price']) / signal['entry_price'] * 100
958|            
959|            timestamp_str = datetime.now(timezone.utc).strftime('%d %b %Y, %H:%M UTC')
960|            
961|            # Ù¾ÛŒØ§Ù… Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ùˆ Ù…Ù†Ø¸Ù…
962|            message = f"{direction_emoji} *{direction_text} SIGNAL*\n"
963|            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
964|            
965|            message += f"ğŸ“Š *{symbol_name}* `{signal['symbol']}`\n"
966|            message += f"â± Timeframe: *{signal['timeframe'].upper()}*\n"
967|            message += f"ğŸ” Structure: `{signal['structure_type']}`\n\n"
968|            
969|            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
970|            message += f"*ENTRY ZONE*\n"
971|            message += f"ğŸ’µ `${signal['entry_price']:.6f}`\n\n"
972|            
973|            message += f"*TAKE PROFIT TARGETS*\n"
974|            for i, target in enumerate(signal['targets'], 1):
975|                if i == 1:
976|                    emoji = "ğŸ¯"
977|                elif i == 2:
978|                    emoji = "ğŸ’š"
979|                else:
980|                    emoji = "âœ¨"
981|                message += f"{emoji} TP{i}: `${target:.6f}`\n"
982|            
983|            message += f"\n*STOP LOSS*\n"
984|            message += f"ğŸ›‘ `${signal['stop_loss']:.6f}`\n\n"
985|            
986|            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
987|            message += f"*TRADE DETAILS*\n"
988|            message += f"âš–ï¸ Risk/Reward: `1:{rr_ratio:.1f}`\n"
989|            message += f"ğŸ“Š Leverage: `{signal['leverage']}x` (Conservative)\n"
990|            message += f"ğŸ’¹ Potential: `+{potential_profit_tp1:.1f}%` to `+{potential_profit_tp3:.1f}%`\n\n"
991|            
992|            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
993|            message += f"âš ï¸ *Risk Management:*\n"
994|            message += f"â€¢ Use proper position sizing\n"
995|            message += f"â€¢ Set stop loss immediately\n"
996|            message += f"â€¢ Take partial profits at each TP\n\n"
997|            
998|            message += f"ğŸ• {timestamp_str}\n"
999|            message += f"ğŸ“ˆ Smart Money Concept Analysis"
1000|            
1001|            # Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„
1002|            sent_message = await self.bot.send_photo(
1003|                chat_id=CHANNEL_ID,
1004|                photo=chart_buffer,
1005|                caption=message,
1006|                parse_mode='Markdown'
1007|            )
1008|            
1009|            # Ø°Ø®ÛŒØ±Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„
1010|            await self.save_signal(signal, sent_message.message_id)
1011|            
1012|            logger.info(f"âœ… Signal sent: {symbol_name} {signal['direction']}")
1013|            
1014|        except TelegramError as e:
1015|            logger.error(f"âŒ Telegram error: {e}")
1016|        except Exception as e:
1017|            logger.error(f"âŒ Error sending signal: {e}")
1018|    
1019|    async def scan_markets(self):
1020|        """Ø§Ø³Ú©Ù† Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ ÛŒØ§ÙØªÙ† ÙØ±ØµØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø§ Ú©ÛŒÙÛŒØª Ø¨Ø§Ù„Ø§"""
1021|        logger.info("ğŸ” Starting market scan...")
1022|        
1023|        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙØ¹Ø§Ù„
1024|        active_trades = await self.check_active_trades()
1025|        signals_found = 0
1026|        
1027|        for coin_id in SYMBOLS.keys():
1028|            # Ø§Ú¯Ø± Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† coin Ù…Ø¹Ø§Ù…Ù„Ù‡ ÙØ¹Ø§Ù„ Ø¯Ø§Ø±ÛŒÙ…ØŒ Ø§Ø³Ú©Ù† Ù†Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
1029|            if coin_id in active_trades:
1030|                logger.info(f"â­ï¸ {coin_id}: Active trade exists, skipping...")
1031|                continue
1032|            
1033|            for timeframe in TIMEFRAMES:
1034|                try:
1035|                    logger.info(f"ğŸ” Analyzing {coin_id} on {timeframe}...")
1036|                    signal = self.analyzer.generate_signal(coin_id, timeframe)
1037|                    
1038|                    if signal:
1039|                        logger.info(f"âœ… HIGH-QUALITY SIGNAL FOUND: {coin_id} {timeframe} {signal['direction']}")
1040|                        await self.send_signal(signal)
1041|                        signals_found += 1
1042|                        
1043|                        # Ø¨Ø±Ø§ÛŒ Ù‡Ø± coin ÙÙ‚Ø· ÛŒÚ© Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¯Ø± Ù‡Ø± Ø¨Ø§Ø± Ø§Ø³Ú©Ù†
1044|                        break
1045|                    
1046|                    # Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒÙ… ØªØ§ rate limit Ù†Ø®ÙˆØ±ÛŒÙ…
1047|                    await asyncio.sleep(2)
1048|                    
1049|                except Exception as e:
1050|                    logger.error(f"âŒ Error scanning {coin_id} {timeframe}: {e}")
1051|                    continue
1052|        
1053|        logger.info(f"âœ… Market scan completed. Signals found: {signals_found}")
1054|    
1055|    async def run(self):
1056|        """Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª Ø¨Ø§ Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ"""
1057|        logger.info("=" * 60)
1058|        logger.info("ğŸ¤– Crypto Signal Bot Starting...")
1059|        logger.info("ğŸ“Š Strategy: Smart Money Concept (SMC)")
1060|        logger.info("ğŸ¯ Focus: HIGH QUALITY signals only")
1061|        logger.info("=" * 60)
1062|        
1063|        # ØªØ³Øª Ø§ØªØµØ§Ù„
1064|        try:
1065|            me = await self.bot.get_me()
1066|            logger.info(f"âœ… Bot connected: @{me.username}")
1067|            logger.info(f"ğŸ“¢ Channel: {CHANNEL_ID}")
1068|        except Exception as e:
1069|            logger.error(f"âŒ Telegram connection failed: {e}")
1070|            logger.error("Please check your BOT_TOKEN and internet connection")
1071|            return
1072|        
1073|        # Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø¯ÛŒØªØ§Ø¨ÛŒØ³
1074|        if USE_DATABASE:
1075|            logger.info("ğŸ’¾ Database: MongoDB Enabled")
1076|        else:
1077|            logger.info("ğŸ’¾ Database: Disabled (Memory-only mode)")
1078|        
1079|        logger.info("=" * 60)
1080|        logger.info("ğŸš€ Bot is now running... Press Ctrl+C to stop")
1081|        logger.info("=" * 60)
1082|        
1083|        while True:
1084|            try:
1085|                # Ø§Ø³Ú©Ù† Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§
1086|                await self.scan_markets()
1087|                
1088|                # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙØ¹Ø§Ù„
1089|                await self.monitor_active_trades()
1090|                
1091|                # Ø§Ø³ØªØ±Ø§Ø­Øª 5 Ø¯Ù‚ÛŒÙ‚Ù‡
1092|                logger.info("â¸ï¸ Waiting 5 minutes before next scan...")
1093|                await asyncio.sleep(300)
1094|                
1095|            except KeyboardInterrupt:
1096|                logger.info("ğŸ›‘ Bot stopped by user")
1097|                break
1098|            except Exception as e:
1099|                logger.error(f"âš ï¸ Unexpected error: {e}")
1100|                logger.info("ğŸ”„ Restarting in 60 seconds...")
1101|                await asyncio.sleep(60)
1102|
1103|
1104|async def main():
1105|    """ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ"""
1106|    bot = TelegramSignalBot()
1107|    await bot.run()
1108|
1109|
1110|if __name__ == "__main__":
1111|    try:
1112|        asyncio.run(main())
1113|    except KeyboardInterrupt:
1114|        logger.info("ğŸ‘‹ Bot shutdown complete")
1115|    except Exception as e:
1116|        logger.error(f"âŒ Fatal error: {e}")
1117|
