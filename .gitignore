
Action: file_editor view /app/telegram_bot.py
Observation: /app/telegram_bot.py:
1|import os
2|import asyncio
3|import logging
4|from datetime import datetime, timezone, timedelta
5|from typing import Dict, List, Optional, Tuple
6|import numpy as np
7|import pandas as pd
8|import matplotlib
9|matplotlib.use('Agg')
10|import matplotlib.pyplot as plt
11|from matplotlib.patches import Rectangle
12|import io
13|import requests
14|from telegram import Bot
15|from telegram.error import TelegramError
16|from motor.motor_asyncio import AsyncIOMotorClient
17|from dotenv import load_dotenv
18|from pathlib import Path
19|import time
20|
21|# Load environment variables
22|ROOT_DIR = Path(__file__).parent
23|load_dotenv(ROOT_DIR / '.env')
24|
25|# Configure logging
26|logging.basicConfig(
27|    level=logging.INFO,
28|    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
29|)
30|logger = logging.getLogger(__name__)
31|
32|# Bot Configuration
33|BOT_TOKEN = "8363442271:AAHGrIjbCz1PX10qERyRecxY6UUxbfW-8Es"
34|CHANNEL_ID = "@Livepricee"
35|
36|# MongoDB connection
37|mongo_url = os.environ.get('MONGO_URL', 'mongodb://localhost:27017')
38|client = AsyncIOMotorClient(mongo_url)
39|db = client['crypto_signals_db']
40|
41|# Trading pairs to monitor (format Ø¨Ø±Ø§ÛŒ CoinGecko)
42|SYMBOLS = {
43|    'bitcoin': {'name': 'Bitcoin', 'ticker': 'BTC'},
44|    'ethereum': {'name': 'Ethereum', 'ticker': 'ETH'},
45|    'shiba-inu': {'name': 'Shiba Inu', 'ticker': 'SHIB'},
46|    'cardano': {'name': 'Cardano', 'ticker': 'ADA'},
47|    'the-open-network': {'name': 'Toncoin', 'ticker': 'TON'},
48|    'solana': {'name': 'Solana', 'ticker': 'SOL'},
49|    'binancecoin': {'name': 'BNB', 'ticker': 'BNB'}
50|}
51|
52|TIMEFRAMES = ['15m', '1h']
53|
54|# ØªØ¨Ø¯ÛŒÙ„ timeframe Ø¨Ù‡ Ø«Ø§Ù†ÛŒÙ‡
55|TIMEFRAME_SECONDS = {
56|    '15m': 900,
57|    '1h': 3600
58|}
59|
60|
61|class CryptoDataFetcher:
62|    """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø±ÛŒÙ¾ØªÙˆ Ø§Ø² CryptoCompare"""
63|    
64|    def __init__(self):
65|        self.base_url = "https://min-api.cryptocompare.com/data"
66|        self.session = requests.Session()
67|        
68|    def get_ohlcv(self, coin_id: str, timeframe: str, limit: int = 200) -> pd.DataFrame:
69|        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ OHLCV Ø§Ø² CryptoCompare"""
70|        try:
71|            # ØªØ¨Ø¯ÛŒÙ„ coin_id Ø¨Ù‡ ticker symbol
72|            ticker = SYMBOLS[coin_id]['ticker']
73|            
74|            # Ø§Ù†ØªØ®Ø§Ø¨ endpoint Ø¨Ø± Ø§Ø³Ø§Ø³ timeframe
75|            # CryptoCompare Ù…Ø­Ø¯ÙˆØ¯ÛŒØª limit = 2000 Ø¯Ø§Ø±Ø¯
76|            if timeframe == '15m':
77|                endpoint = f"{self.base_url}/v2/histominute"
78|                actual_limit = min(limit * 15, 2000)
79|                params = {
80|                    'fsym': ticker,
81|                    'tsym': 'USDT',
82|                    'limit': actual_limit,
83|                    'aggregate': 15
84|                }
85|            else:  # 1h
86|                endpoint = f"{self.base_url}/v2/histohour"
87|                actual_limit = min(limit, 2000)
88|                params = {
89|                    'fsym': ticker,
90|                    'tsym': 'USDT',
91|                    'limit': actual_limit
92|                }
93|            
94|            response = self.session.get(endpoint, params=params, timeout=15)
95|            response.raise_for_status()
96|            data = response.json()
97|            
98|            if data.get('Response') == 'Error':
99|                logger.error(f"Ø®Ø·Ø§ÛŒ API: {data.get('Message')}")
100|                return None
101|            
102|            if 'Data' not in data or 'Data' not in data['Data']:
103|                return None
104|            
105|            # ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ DataFrame
106|            ohlcv_data = data['Data']['Data']
107|            df = pd.DataFrame(ohlcv_data)
108|            
109|            if df.empty:
110|                return None
111|            
112|            # Ø§Ù†ØªØ®Ø§Ø¨ Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ùˆ ØªØºÛŒÛŒØ± Ù†Ø§Ù…
113|            df = df[['time', 'open', 'high', 'low', 'close', 'volumeto']].copy()
114|            df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
115|            
116|            # ØªØ¨Ø¯ÛŒÙ„ timestamp Ø¨Ù‡ datetime
117|            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s')
118|            
119|            # Ø­Ø°Ù Ø±Ø¯ÛŒÙâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± ØµÙØ±
120|            df = df[(df['open'] > 0) & (df['high'] > 0) & (df['low'] > 0) & (df['close'] > 0)]
121|            
122|            return df.reset_index(drop=True)
123|            
124|        except Exception as e:
125|            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ {coin_id}: {e}")
126|            return None
127|    
128|    def get_current_price(self, coin_id: str) -> float:
129|        """Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ"""
130|        try:
131|            ticker = SYMBOLS[coin_id]['ticker']
132|            url = f"{self.base_url}/price"
133|            params = {
134|                'fsym': ticker,
135|                'tsyms': 'USDT'
136|            }
137|            
138|            response = self.session.get(url, params=params, timeout=10)
139|            response.raise_for_status()
140|            data = response.json()
141|            
142|            return data.get('USDT')
143|            
144|        except Exception as e:
145|            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª {coin_id}: {e}")
146|            return None
147|
148|
149|# Ø³Ø§Ø®Øª Ù†Ù…ÙˆÙ†Ù‡ fetcher
150|data_fetcher = CryptoDataFetcher()
151|
152|
153|class SmartMoneyAnalyzer:
154|    """ØªØ­Ù„ÛŒÙ„Ú¯Ø± Smart Money Concept"""
155|    
156|    def __init__(self):
157|        self.lookback_periods = 50
158|        self.min_rr_ratio = 2.0  # Minimum Risk/Reward ratio
159|        self.volume_threshold = 1.5  # Volume must be 1.5x average
160|        
161|    def detect_swing_points(self, df: pd.DataFrame) -> Tuple[List, List]:
162|        """Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Swing High Ùˆ Swing Low"""
163|        swing_highs = []
164|        swing_lows = []
165|        
166|        for i in range(2, len(df) - 2):
167|            # Swing High: Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø² 2 Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ Ùˆ 2 Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯
168|            if (df['high'].iloc[i] > df['high'].iloc[i-1] and 
169|                df['high'].iloc[i] > df['high'].iloc[i-2] and
170|                df['high'].iloc[i] > df['high'].iloc[i+1] and 
171|                df['high'].iloc[i] > df['high'].iloc[i+2]):
172|                swing_highs.append({
173|                    'index': i,
174|                    'price': df['high'].iloc[i],
175|                    'time': df.index[i]
176|                })
177|            
178|            # Swing Low: Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² 2 Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ Ùˆ 2 Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯
179|            if (df['low'].iloc[i] < df['low'].iloc[i-1] and 
180|                df['low'].iloc[i] < df['low'].iloc[i-2] and
181|                df['low'].iloc[i] < df['low'].iloc[i+1] and 
182|                df['low'].iloc[i] < df['low'].iloc[i+2]):
183|                swing_lows.append({
184|                    'index': i,
185|                    'price': df['low'].iloc[i],
186|                    'time': df.index[i]
187|                })
188|        
189|        return swing_highs, swing_lows
190|    
191|    def detect_bos_choch(self, df: pd.DataFrame, swing_highs: List, swing_lows: List) -> Dict:
192|        """Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Break of Structure (BOS) Ùˆ Change of Character (CHoCH)"""
193|        if len(swing_highs) < 2 or len(swing_lows) < 2:
194|            return None
195|        
196|        last_swing_high = swing_highs[-1]['price']
197|        last_swing_low = swing_lows[-1]['price']
198|        current_price = df['close'].iloc[-1]
199|        
200|        # BOS Bullish: Ø´Ú©Ø³Øª Ø¢Ø®Ø±ÛŒÙ† swing high
201|        if current_price > last_swing_high:
202|            return {
203|                'type': 'BOS_BULLISH',
204|                'signal': 'LONG',
205|                'level': last_swing_high
206|            }
207|        
208|        # BOS Bearish: Ø´Ú©Ø³Øª Ø¢Ø®Ø±ÛŒÙ† swing low
209|        if current_price < last_swing_low:
210|            return {
211|                'type': 'BOS_BEARISH',
212|                'signal': 'SHORT',
213|                'level': last_swing_low
214|            }
215|        
216|        return None
217|    
218|    def detect_order_blocks(self, df: pd.DataFrame, signal_type: str) -> Optional[Dict]:
219|        """Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Order Blocks"""
220|        order_blocks = []
221|        
222|        for i in range(len(df) - 10, len(df) - 1):
223|            candle = df.iloc[i]
224|            next_candle = df.iloc[i + 1]
225|            
226|            # Bullish Order Block
227|            if signal_type == 'LONG':
228|                # Ø¢Ø®Ø±ÛŒÙ† Ú©Ù†Ø¯Ù„ Ù†Ø²ÙˆÙ„ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø­Ø±Ú©Øª ØµØ¹ÙˆØ¯ÛŒ Ù‚ÙˆÛŒ
229|                if (candle['close'] < candle['open'] and 
230|                    next_candle['close'] > next_candle['open'] and
231|                    (next_candle['close'] - next_candle['open']) > 2 * abs(candle['close'] - candle['open'])):
232|                    order_blocks.append({
233|                        'type': 'BULLISH_OB',
234|                        'high': candle['high'],
235|                        'low': candle['low'],
236|                        'index': i
237|                    })
238|            
239|            # Bearish Order Block
240|            elif signal_type == 'SHORT':
241|                # Ø¢Ø®Ø±ÛŒÙ† Ú©Ù†Ø¯Ù„ ØµØ¹ÙˆØ¯ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø­Ø±Ú©Øª Ù†Ø²ÙˆÙ„ÛŒ Ù‚ÙˆÛŒ
242|                if (candle['close'] > candle['open'] and 
243|                    next_candle['close'] < next_candle['open'] and
244|                    (next_candle['open'] - next_candle['close']) > 2 * abs(candle['close'] - candle['open'])):
245|                    order_blocks.append({
246|                        'type': 'BEARISH_OB',
247|                        'high': candle['high'],
248|                        'low': candle['low'],
249|                        'index': i
250|                    })
251|        
252|        return order_blocks[-1] if order_blocks else None
253|    
254|    def detect_fvg(self, df: pd.DataFrame) -> List[Dict]:
255|        """Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Fair Value Gaps (FVG)"""
256|        fvgs = []
257|        
258|        for i in range(1, len(df) - 1):
259|            prev_candle = df.iloc[i - 1]
260|            current_candle = df.iloc[i]
261|            next_candle = df.iloc[i + 1]
262|            
263|            # Bullish FVG: Ú¯Ù¾ Ø¨ÛŒÙ† low Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯ÛŒ Ùˆ high Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ÛŒ
264|            if next_candle['low'] > prev_candle['high']:
265|                fvgs.append({
266|                    'type': 'BULLISH_FVG',
267|                    'top': next_candle['low'],
268|                    'bottom': prev_candle['high'],
269|                    'index': i
270|                })
271|            
272|            # Bearish FVG: Ú¯Ù¾ Ø¨ÛŒÙ† high Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯ÛŒ Ùˆ low Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ÛŒ
273|            if next_candle['high'] < prev_candle['low']:
274|                fvgs.append({
275|                    'type': 'BEARISH_FVG',
276|                    'top': prev_candle['low'],
277|                    'bottom': next_candle['high'],
278|                    'index': i
279|                })
280|        
281|        # ÙÙ‚Ø· Ø¢Ø®Ø±ÛŒÙ† FVG Ù‡Ø§ Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†
282|        return fvgs[-3:] if fvgs else []
283|    
284|    def calculate_premium_discount(self, df: pd.DataFrame, swing_highs: List, swing_lows: List) -> Dict:
285|        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Premium Ùˆ Discount Zone"""
286|        if not swing_highs or not swing_lows:
287|            return None
288|        
289|        recent_high = max([sh['price'] for sh in swing_highs[-3:]])
290|        recent_low = min([sl['price'] for sl in swing_lows[-3:]])
291|        
292|        range_size = recent_high - recent_low
293|        current_price = df['close'].iloc[-1]
294|        
295|        # Premium zone: 50% - 100% of range
296|        premium_threshold = recent_low + (range_size * 0.5)
297|        
298|        # Discount zone: 0% - 50% of range
299|        discount_threshold = recent_low + (range_size * 0.5)
300|        
301|        equilibrium = recent_low + (range_size * 0.5)
302|        
303|        if current_price >= premium_threshold:
304|            zone = 'PREMIUM'
305|        elif current_price <= discount_threshold:
306|            zone = 'DISCOUNT'
307|        else:
308|            zone = 'EQUILIBRIUM'
309|        
310|        return {
311|            'zone': zone,
312|            'high': recent_high,
313|            'low': recent_low,
314|            'equilibrium': equilibrium,
315|            'current': current_price
316|        }
317|    
318|    def calculate_ema(self, df: pd.DataFrame, period: int) -> pd.Series:
319|        """Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ ØªØ±Ù†Ø¯"""
320|        return df['close'].ewm(span=period, adjust=False).mean()
321|    
322|    def calculate_atr(self, df: pd.DataFrame, period: int = 14) -> float:
323|        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Average True Range"""
324|        high_low = df['high'] - df['low']
325|        high_close = np.abs(df['high'] - df['close'].shift())
326|        low_close = np.abs(df['low'] - df['close'].shift())
327|        
328|        ranges = pd.concat([high_low, high_close, low_close], axis=1)
329|        true_range = np.max(ranges, axis=1)
330|        atr = true_range.rolling(period).mean().iloc[-1]
331|        
332|        return atr
333|    
334|    def check_volume_confirmation(self, df: pd.DataFrame) -> bool:
335|        """ØªØ£ÛŒÛŒØ¯ Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª"""
336|        if len(df) < 20:
337|            return False
338|        
339|        avg_volume = df['volume'].tail(20).mean()
340|        recent_volume = df['volume'].tail(5).mean()
341|        
342|        # Ø­Ø¬Ù… Ø¨Ø§ÛŒØ¯ 1.5 Ø¨Ø±Ø§Ø¨Ø± Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¨Ø§Ø´Ø¯
343|        return recent_volume >= (avg_volume * self.volume_threshold)
344|    
345|    def check_trend_alignment(self, df: pd.DataFrame, signal_direction: str) -> bool:
346|        """ØªØ£ÛŒÛŒØ¯ Ù‡Ù…Ø³ÙˆÛŒÛŒ Ø¨Ø§ ØªØ±Ù†Ø¯ Ø§ØµÙ„ÛŒ"""
347|        ema_20 = self.calculate_ema(df, 20)
348|        ema_50 = self.calculate_ema(df, 50)
349|        
350|        current_price = df['close'].iloc[-1]
351|        
352|        if signal_direction == 'LONG':
353|            # Ø¨Ø±Ø§ÛŒ Long: EMA20 > EMA50 Ùˆ Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ÛŒ EMA20
354|            return ema_20.iloc[-1] > ema_50.iloc[-1] and current_price > ema_20.iloc[-1]
355|        else:  # SHORT
356|            # Ø¨Ø±Ø§ÛŒ Short: EMA20 < EMA50 Ùˆ Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÛŒÙ† EMA20
357|            return ema_20.iloc[-1] < ema_50.iloc[-1] and current_price < ema_20.iloc[-1]
358|    
359|    def generate_signal(self, coin_id: str, timeframe: str) -> Optional[Dict]:
360|        """ØªÙˆÙ„ÛŒØ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø§ ÙÛŒÙ„ØªØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡"""
361|        try:
362|            # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚ÛŒÙ…ØªÛŒ
363|            df = data_fetcher.get_ohlcv(coin_id, timeframe, limit=150)
364|            
365|            if df is None or len(df) < 60:
366|                return None
367|            
368|            df.set_index('timestamp', inplace=True)
369|            
370|            # ØªØ­Ù„ÛŒÙ„ Smart Money
371|            swing_highs, swing_lows = self.detect_swing_points(df)
372|            
373|            if len(swing_highs) < 3 or len(swing_lows) < 3:
374|                return None
375|            
376|            # Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ BOS/CHoCH
377|            structure = self.detect_bos_choch(df, swing_highs, swing_lows)
378|            
379|            if not structure:
380|                return None
381|            
382|            # ØªØ£ÛŒÛŒØ¯ Volume
383|            volume_confirmed = self.check_volume_confirmation(df)
384|            if not volume_confirmed:
385|                logger.info(f"{coin_id}: Volume confirmation failed")
386|                return None
387|            
388|            # ØªØ£ÛŒÛŒØ¯ Trend
389|            trend_aligned = self.check_trend_alignment(df, structure['signal'])
390|            if not trend_aligned:
391|                logger.info(f"{coin_id}: Trend alignment failed")
392|                return None
393|            
394|            # Order Blocks
395|            order_block = self.detect_order_blocks(df, structure['signal'])
396|            if not order_block:
397|                logger.info(f"{coin_id}: No valid Order Block found")
398|                return None
399|            
400|            # Fair Value Gaps
401|            fvgs = self.detect_fvg(df)
402|            
403|            # Premium/Discount Zone
404|            pd_zone = self.calculate_premium_discount(df, swing_highs, swing_lows)
405|            
406|            current_price = df['close'].iloc[-1]
407|            atr = self.calculate_atr(df)
408|            
409|            # Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± Ú†Ø§Ø±Øª
410|            ema_20 = self.calculate_ema(df, 20)
411|            ema_50 = self.calculate_ema(df, 50)
412|            
413|            # Ø´Ø±Ø§ÛŒØ· ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡
414|            valid_signal = False
415|            
416|            if structure['signal'] == 'LONG':
417|                # Ø¨Ø±Ø§ÛŒ Long: Ø¨Ø§ÛŒØ¯ Ø¯Ø± Discount Zone Ø¨Ø§Ø´ÛŒÙ…
418|                if pd_zone and pd_zone['zone'] == 'DISCOUNT':
419|                    valid_signal = True
420|                    entry_price = current_price
421|                    stop_loss = order_block['low'] - (atr * 0.5)  # ATR-based SL
422|                    risk = entry_price - stop_loss
423|                    
424|                    # Targets Ø¨Ø§ Ù†Ø³Ø¨Øª 2:1, 3:1, 4:1
425|                    target1 = entry_price + (risk * 2.0)
426|                    target2 = entry_price + (risk * 3.0)
427|                    target3 = entry_price + (risk * 4.0)
428|            
429|            elif structure['signal'] == 'SHORT':
430|                # Ø¨Ø±Ø§ÛŒ Short: Ø¨Ø§ÛŒØ¯ Ø¯Ø± Premium Zone Ø¨Ø§Ø´ÛŒÙ…
431|                if pd_zone and pd_zone['zone'] == 'PREMIUM':
432|                    valid_signal = True
433|                    entry_price = current_price
434|                    stop_loss = order_block['high'] + (atr * 0.5)  # ATR-based SL
435|                    risk = stop_loss - entry_price
436|                    
437|                    # Targets Ø¨Ø§ Ù†Ø³Ø¨Øª 2:1, 3:1, 4:1
438|                    target1 = entry_price - (risk * 2.0)
439|                    target2 = entry_price - (risk * 3.0)
440|                    target3 = entry_price - (risk * 4.0)
441|            
442|            if not valid_signal:
443|                return None
444|            
445|            # Ø¨Ø±Ø±Ø³ÛŒ Ø­Ø¯Ø§Ù‚Ù„ R/R
446|            rr_ratio = abs(target1 - entry_price) / risk
447|            if rr_ratio < self.min_rr_ratio:
448|                logger.info(f"{coin_id}: R/R ratio too low ({rr_ratio:.2f})")
449|                return None
450|            
451|            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù„ÙˆØ±ÛŒØ¬ Ù…Ø­Ø§ÙØ¸Ù‡â€ŒÚ©Ø§Ø±Ø§Ù†Ù‡
452|            risk_percent = (risk / entry_price) * 100
453|            if risk_percent < 1.5:
454|                leverage = 10
455|            elif risk_percent < 2.5:
456|                leverage = 7
457|            elif risk_percent < 4:
458|                leverage = 5
459|            else:
460|                leverage = 3
461|            
462|            signal = {
463|                'coin_id': coin_id,
464|                'symbol': SYMBOLS[coin_id]['ticker'] + '/USDT',
465|                'timeframe': timeframe,
466|                'direction': structure['signal'],
467|                'entry_price': round(entry_price, 8),
468|                'stop_loss': round(stop_loss, 8),
469|                'targets': [
470|                    round(target1, 8),
471|                    round(target2, 8),
472|                    round(target3, 8)
473|                ],
474|                'leverage': leverage,
475|                'structure_type': structure['type'],
476|                'order_block': order_block,
477|                'fvgs': fvgs,
478|                'pd_zone': pd_zone,
479|                'df': df,
480|                'swing_highs': swing_highs,
481|                'swing_lows': swing_lows,
482|                'ema_20': ema_20,
483|                'ema_50': ema_50,
484|                'atr': atr,
485|                'rr_ratio': rr_ratio,
486|                'timestamp': datetime.now(timezone.utc)
487|            }
488|            
489|            return signal
490|            
491|        except Exception as e:
492|            logger.error(f"Error generating signal for {coin_id}: {e}")
493|            return None
494|
495|
496|class ChartGenerator:
497|    """ØªÙˆÙ„ÛŒØ¯ Ú†Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ ØªØ­Ù„ÛŒÙ„ÛŒ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ"""
498|    
499|    @staticmethod
500|    def create_chart(signal: Dict) -> io.BytesIO:
501|        """Ø³Ø§Ø®Øª Ú†Ø§Ø±Øª Ú©Ù†Ø¯Ù„ÛŒ Ø¨Ø§ ØªØ­Ù„ÛŒÙ„ SMC - TradingView Style"""
502|        df = signal['df'].tail(100)  # Ø¢Ø®Ø±ÛŒÙ† 100 Ú©Ù†Ø¯Ù„
503|        
504|        # TradingView style: background Ø³ÙÛŒØ¯
505|        fig, ax = plt.subplots(figsize=(20, 12))
506|        fig.patch.set_facecolor('#ffffff')
507|        ax.set_facecolor('#ffffff')
508|        
509|        # Ø±Ø³Ù… EMA Ù‡Ø§
510|        if 'ema_20' in signal and 'ema_50' in signal:
511|            ema_20_values = signal['ema_20'].tail(100).values
512|            ema_50_values = signal['ema_50'].tail(100).values
513|            
514|            ax.plot(range(len(ema_20_values)), ema_20_values, 
515|                   color='#2962FF', linewidth=2, label='EMA 20', alpha=0.8, zorder=2)
516|            ax.plot(range(len(ema_50_values)), ema_50_values, 
517|                   color='#FF6D00', linewidth=2, label='EMA 50', alpha=0.8, zorder=2)
518|        
519|        # Ø±Ø³Ù… Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ - TradingView colors
520|        for idx in range(len(df)):
521|            row = df.iloc[idx]
522|            
523|            # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø¹ØªØ¨Ø± Ù‡Ø³ØªÙ†Ø¯
524|            if pd.isna(row['open']) or pd.isna(row['close']) or pd.isna(row['high']) or pd.isna(row['low']):
525|                continue
526|            
527|            # TradingView default colors
528|            is_bullish = row['close'] >= row['open']
529|            candle_color = '#089981' if is_bullish else '#F23645'
530|            wick_color = '#089981' if is_bullish else '#F23645'
531|            
532|            # Ø¨Ø¯Ù†Ù‡ Ú©Ù†Ø¯Ù„
533|            height = abs(row['close'] - row['open'])
534|            if height == 0:
535|                height = 0.0001  # Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø®Ø·Ø§
536|            bottom = min(row['open'], row['close'])
537|            
538|            ax.add_patch(Rectangle((idx - 0.4, bottom), 0.8, height, 
539|                                   facecolor=candle_color, edgecolor=candle_color, 
540|                                   alpha=0.9, linewidth=1, zorder=3))
541|            
542|            # Ø³Ø§ÛŒÙ‡ Ú©Ù†Ø¯Ù„
543|            ax.plot([idx, idx], [row['low'], row['high']], 
544|                   color=wick_color, linewidth=1.5, alpha=0.8, zorder=2)
545|        
546|        # Ø±Ø³Ù… Premium/Discount Zones
547|        if signal.get('pd_zone'):
548|            pd_zone = signal['pd_zone']
549|            ax.axhspan(pd_zone['equilibrium'], pd_zone['high'], 
550|                      alpha=0.08, color='#F23645', label='Premium Zone', zorder=0)
551|            ax.axhspan(pd_zone['low'], pd_zone['equilibrium'], 
552|                      alpha=0.08, color='#089981', label='Discount Zone', zorder=0)
553|            ax.axhline(pd_zone['equilibrium'], color='#787B86', 
554|                      linestyle='--', linewidth=1.5, alpha=0.7, label='Equilibrium', zorder=1)
555|        
556|        # Ø±Ø³Ù… Order Block Ø¨Ø§ label
557|        if signal.get('order_block'):
558|            ob = signal['order_block']
559|            ob_color = '#089981' if signal['direction'] == 'LONG' else '#F23645'
560|            ax.axhspan(ob['low'], ob['high'], alpha=0.25, color=ob_color, 
561|                      label='Order Block', zorder=1, edgecolor=ob_color, linewidth=2)
562|            
563|            # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† text label Ø¨Ø±Ø§ÛŒ Order Block
564|            mid_price = (ob['low'] + ob['high']) / 2
565|            ax.text(len(df) - 15, mid_price, 'OB', 
566|                   fontsize=12, fontweight='bold', color=ob_color,
567|                   bbox=dict(boxstyle='round,pad=0.5', facecolor='white', 
568|                            edgecolor=ob_color, linewidth=2), zorder=4)
569|        
570|        # Ø±Ø³Ù… Fair Value Gaps
571|        for i, fvg in enumerate(signal.get('fvgs', [])):
572|            fvg_color = '#2962FF' if 'BULLISH' in fvg['type'] else '#FF6D00'
573|            ax.axhspan(fvg['bottom'], fvg['top'], alpha=0.15, 
574|                      color=fvg_color, zorder=1, linestyle='--', 
575|                      edgecolor=fvg_color, linewidth=1)
576|        
577|        # Ø±Ø³Ù… Swing Points
578|        for sh in signal.get('swing_highs', [])[-8:]:
579|            if sh['index'] < len(df):
580|                ax.plot(sh['index'], sh['price'], 'v', 
581|                       color='#F23645', markersize=10, markeredgecolor='white', 
582|                       markeredgewidth=1.5, zorder=4)
583|        
584|        for sl in signal.get('swing_lows', [])[-8:]:
585|            if sl['index'] < len(df):
586|                ax.plot(sl['index'], sl['price'], '^', 
587|                       color='#089981', markersize=10, markeredgecolor='white',
588|                       markeredgewidth=1.5, zorder=4)
589|        
590|        # Ù†Ù‚Ø·Ù‡ ÙˆØ±ÙˆØ¯ - Ø¨Ø²Ø±Ú¯ØªØ± Ùˆ ÙˆØ§Ø¶Ø­â€ŒØªØ±
591|        entry_idx = len(df) - 1
592|        entry_price = signal['entry_price']
593|        entry_color = '#2962FF' if signal['direction'] == 'LONG' else '#F23645'
594|        ax.plot(entry_idx, entry_price, 'D', color=entry_color, markersize=15, 
595|               markeredgecolor='white', markeredgewidth=2.5, label='ENTRY', zorder=6)
596|        
597|        # Ø®Ø· Entry
598|        ax.axhline(entry_price, color=entry_color, linestyle='-', 
599|                  linewidth=2, alpha=0.5, zorder=1)
600|        
601|        # Stop Loss - Ù‚Ø±Ù…Ø² Ùˆ ÙˆØ§Ø¶Ø­
602|        ax.axhline(signal['stop_loss'], color='#F23645', linestyle='--', 
603|                  linewidth=2.5, label=f"SL: ${signal['stop_loss']:.4f}", alpha=0.9, zorder=2)
604|        
605|        # Targets - Ø³Ø¨Ø² Ùˆ ÙˆØ§Ø¶Ø­
606|        target_colors = ['#26A69A', '#00897B', '#00695C']
607|        for i, target in enumerate(signal['targets']):
608|            ax.axhline(target, color=target_colors[i], linestyle='--', 
609|                      linewidth=2.5, label=f"TP{i+1}: ${target:.4f}", alpha=0.9, zorder=2)
610|            
611|            # Label Ø±ÙˆÛŒ Ø®Ø·
612|            ax.text(len(df) - 5, target, f'TP{i+1}', 
613|                   fontsize=11, fontweight='bold', color=target_colors[i],
614|                   bbox=dict(boxstyle='round,pad=0.4', facecolor='white', 
615|                            edgecolor=target_colors[i], linewidth=2), 
616|                   ha='center', zorder=5)
617|        
618|        # Grid - Ø³Ø¨Ú© TradingView
619|        ax.grid(True, alpha=0.2, color='#E0E3EB', linestyle='-', linewidth=0.5)
620|        ax.set_axisbelow(True)
621|        
622|        # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø­ÙˆØ± - Ø³Ø¨Ú© TradingView
623|        ax.tick_params(colors='#131722', labelsize=11)
624|        for spine in ax.spines.values():
625|            spine.set_color('#E0E3EB')
626|            spine.set_linewidth(1)
627|        
628|        # Ø¹Ù†ÙˆØ§Ù† Ùˆ Ø¨Ø±Ú†Ø³Ø¨â€ŒÙ‡Ø§
629|        direction_emoji = "ğŸŸ¢ LONG" if signal['direction'] == 'LONG' else "ğŸ”´ SHORT"
630|        coin_data = SYMBOLS.get(signal['coin_id'])
631|        title_name = coin_data['name'] if coin_data else signal['symbol']
632|        
633|        # Ø¹Ù†ÙˆØ§Ù† Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ
634|        title = f"{direction_emoji} | {title_name} ({signal['symbol']}) | {signal['timeframe'].upper()}"
635|        subtitle = f"Smart Money Concept Analysis | R/R: 1:{signal.get('rr_ratio', 0):.1f}"
636|        
637|        ax.set_title(title, color='#131722', fontsize=20, fontweight='bold', pad=15)
638|        ax.text(0.5, 1.02, subtitle, transform=ax.transAxes, 
639|               fontsize=12, ha='center', color='#787B86')
640|        
641|        ax.set_xlabel('Time Period', color='#131722', fontsize=13, fontweight='bold')
642|        ax.set_ylabel('Price (USDT)', color='#131722', fontsize=13, fontweight='bold')
643|        
644|        # Legend - Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ
645|        legend = ax.legend(loc='upper left', fontsize=10, framealpha=0.95, 
646|                          facecolor='white', edgecolor='#E0E3EB', 
647|                          shadow=True, ncol=2)
648|        legend.get_frame().set_linewidth(1.5)
649|        
650|        plt.tight_layout()
651|        
652|        # Ø°Ø®ÛŒØ±Ù‡ Ø¨Ø§ Ú©ÛŒÙÛŒØª Ø¨Ø§Ù„Ø§
653|        buf = io.BytesIO()
654|        plt.savefig(buf, format='png', dpi=300, facecolor='#ffffff', 
655|                   edgecolor='none', bbox_inches='tight')
656|        buf.seek(0)
657|        plt.close()
658|        
659|        return buf
660|
661|
662|class TelegramSignalBot:
663|    """Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§"""
664|    
665|    def __init__(self):
666|        self.bot = Bot(token=BOT_TOKEN)
667|        self.analyzer = SmartMoneyAnalyzer()
668|        self.chart_gen = ChartGenerator()
669|        
670|    async def check_active_trades(self) -> Dict[str, Dict]:
671|        """Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙØ¹Ø§Ù„"""
672|        active_trades = {}
673|        
674|        cursor = db.active_signals.find({})
675|        async for trade in cursor:
676|            coin_id = trade.get('coin_id', trade.get('symbol'))
677|            active_trades[coin_id] = trade
678|        
679|        return active_trades
680|    
681|    async def save_signal(self, signal: Dict, message_id: int):
682|        """Ø°Ø®ÛŒØ±Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
683|        signal_doc = {
684|            'coin_id': signal['coin_id'],
685|            'symbol': signal['symbol'],
686|            'timeframe': signal['timeframe'],
687|            'direction': signal['direction'],
688|            'entry_price': signal['entry_price'],
689|            'stop_loss': signal['stop_loss'],
690|            'targets': signal['targets'],
691|            'leverage': signal['leverage'],
692|            'message_id': message_id,
693|            'status': 'ACTIVE',
694|            'targets_hit': [],
695|            'created_at': datetime.now(timezone.utc).isoformat()
696|        }
697|        
698|        await db.active_signals.insert_one(signal_doc)
699|        logger.info(f"Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯: {signal['symbol']} {signal['direction']}")
700|    
701|    async def update_trade_status(self, coin_id: str, status: str, hit_target: Optional[int] = None):
702|        """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ù‡"""
703|        update_data = {'status': status}
704|        
705|        if hit_target:
706|            await db.active_signals.update_one(
707|                {'coin_id': coin_id, 'status': 'ACTIVE'},
708|                {'$push': {'targets_hit': hit_target}}
709|            )
710|        else:
711|            await db.active_signals.update_one(
712|                {'coin_id': coin_id, 'status': 'ACTIVE'},
713|                {'$set': update_data}
714|            )
715|    
716|    async def monitor_active_trades(self):
717|        """Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙØ¹Ø§Ù„ Ùˆ Ú†Ú© Ú©Ø±Ø¯Ù† TP/SL"""
718|        active_trades = await self.check_active_trades()
719|        
720|        for coin_id, trade in active_trades.items():
721|            try:
722|                # Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
723|                current_price = data_fetcher.get_current_price(coin_id)
724|                
725|                if current_price is None:
726|                    continue
727|                
728|                # Ø¨Ø±Ø±Ø³ÛŒ Stop Loss
729|                if trade['direction'] == 'LONG':
730|                    if current_price <= trade['stop_loss']:
731|                        await self.send_trade_update(trade, 'STOP_LOSS', current_price)
732|                        await self.update_trade_status(coin_id, 'CLOSED_SL')
733|                        await db.active_signals.delete_one({'coin_id': coin_id})
734|                        continue
735|                    
736|                    # Ø¨Ø±Ø±Ø³ÛŒ Targets
737|                    for i, target in enumerate(trade['targets'], 1):
738|                        if current_price >= target and i not in trade.get('targets_hit', []):
739|                            await self.send_trade_update(trade, f'TARGET_{i}', current_price)
740|                            await self.update_trade_status(coin_id, 'ACTIVE', i)
741|                            
742|                            # Ø§Ú¯Ø± Ù‡Ù…Ù‡ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ù‡ÛŒØª Ø´Ø¯
743|                            if i == len(trade['targets']):
744|                                await self.update_trade_status(coin_id, 'CLOSED_TP')
745|                                await db.active_signals.delete_one({'coin_id': coin_id})
746|                
747|                else:  # SHORT
748|                    if current_price >= trade['stop_loss']:
749|                        await self.send_trade_update(trade, 'STOP_LOSS', current_price)
750|                        await self.update_trade_status(coin_id, 'CLOSED_SL')
751|                        await db.active_signals.delete_one({'coin_id': coin_id})
752|                        continue
753|                    
754|                    # Ø¨Ø±Ø±Ø³ÛŒ Targets
755|                    for i, target in enumerate(trade['targets'], 1):
756|                        if current_price <= target and i not in trade.get('targets_hit', []):
757|                            await self.send_trade_update(trade, f'TARGET_{i}', current_price)
758|                            await self.update_trade_status(coin_id, 'ACTIVE', i)
759|                            
760|                            # Ø§Ú¯Ø± Ù‡Ù…Ù‡ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ù‡ÛŒØª Ø´Ø¯
761|                            if i == len(trade['targets']):
762|                                await self.update_trade_status(coin_id, 'CLOSED_TP')
763|                                await db.active_signals.delete_one({'coin_id': coin_id})
764|            
765|            except Exception as e:
766|                logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯ {coin_id}: {e}")
767|    
768|    async def send_trade_update(self, trade: Dict, update_type: str, current_price: float):
769|        """Ø§Ø±Ø³Ø§Ù„ Ø¢Ù¾Ø¯ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„ - English & Professional"""
770|        try:
771|            # Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù†Ø§Ù… Ø§Ø±Ø²
772|            coin_id = trade.get('coin_id', '')
773|            coin_data = SYMBOLS.get(coin_id, {})
774|            symbol_name = coin_data.get('name', trade['symbol'])
775|            
776|            if update_type == 'STOP_LOSS':
777|                emoji = "ğŸ›‘"
778|                message = f"{emoji} *STOP LOSS TRIGGERED*\n"
779|                message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
780|                message += f"*{symbol_name}* `{trade['symbol']}`\n"
781|                message += f"Direction: *{trade['direction']}*\n\n"
782|                message += f"Entry Price: `${trade['entry_price']:.6f}`\n"
783|                message += f"Stop Loss: `${trade['stop_loss']:.6f}`\n"
784|                message += f"Exit Price: `${current_price:.6f}`\n\n"
785|                
786|                loss_percent = abs((current_price - trade['entry_price']) / trade['entry_price'] * 100)
787|                message += f"ğŸ“‰ Loss: *-{loss_percent:.2f}%*\n\n"
788|                message += f"âš ï¸ Trade closed at stop loss"
789|            
790|            elif 'TARGET' in update_type:
791|                target_num = int(update_type.split('_')[1])
792|                
793|                if target_num == 1:
794|                    emoji = "âœ…"
795|                elif target_num == 2:
796|                    emoji = "ğŸ’š"
797|                else:
798|                    emoji = "ğŸ¯"
799|                
800|                message = f"{emoji} *TARGET {target_num} REACHED*\n"
801|                message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
802|                message += f"*{symbol_name}* `{trade['symbol']}`\n"
803|                message += f"Direction: *{trade['direction']}*\n\n"
804|                message += f"Entry Price: `${trade['entry_price']:.6f}`\n"
805|                message += f"Target {target_num}: `${trade['targets'][target_num-1]:.6f}`\n"
806|                message += f"Current Price: `${current_price:.6f}`\n\n"
807|                
808|                profit_percent = abs((current_price - trade['entry_price']) / trade['entry_price'] * 100)
809|                leverage_profit = profit_percent * trade.get('leverage', 1)
810|                
811|                message += f"ğŸ“ˆ Profit: *+{profit_percent:.2f}%*\n"
812|                message += f"ğŸ’° With {trade.get('leverage', 1)}x Leverage: *+{leverage_profit:.2f}%*\n\n"
813|                
814|                if target_num == len(trade['targets']):
815|                    message += f"ğŸ‰ *ALL TARGETS HIT!*\n"
816|                    message += f"âœ¨ Trade completed successfully!"
817|                else:
818|                    message += f"â« Moving to next target..."
819|            
820|            # Reply Ø¨Ù‡ Ù¾ÛŒØ§Ù… Ø§ØµÙ„ÛŒ
821|            await self.bot.send_message(
822|                chat_id=CHANNEL_ID,
823|                text=message,
824|                parse_mode='Markdown',
825|                reply_to_message_id=trade['message_id']
826|            )
827|            
828|            logger.info(f"Update sent: {symbol_name} - {update_type}")
829|            
830|        except Exception as e:
831|            logger.error(f"Error sending update: {e}")
832|    
833|    async def send_signal(self, signal: Dict):
834|        """Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„ ØªÙ„Ú¯Ø±Ø§Ù… - Professional Format"""
835|        try:
836|            # ØªÙˆÙ„ÛŒØ¯ Ú†Ø§Ø±Øª
837|            chart_buffer = self.chart_gen.create_chart(signal)
838|            
839|            # Ù…ØªÙ† Ù¾ÛŒØ§Ù…
840|            coin_data = SYMBOLS.get(signal['coin_id'])
841|            symbol_name = coin_data['name'] if coin_data else signal['symbol']
842|            
843|            # Direction with emoji
844|            if signal['direction'] == 'LONG':
845|                direction_emoji = "ğŸŸ¢"
846|                direction_text = "LONG"
847|            else:
848|                direction_emoji = "ğŸ”´"
849|                direction_text = "SHORT"
850|            
851|            # Risk/Reward
852|            risk = abs(signal['entry_price'] - signal['stop_loss'])
853|            rr_ratio = signal.get('rr_ratio', 2.0)
854|            
855|            # Ù…Ø­Ø§Ø³Ø¨Ù‡ potential profit
856|            potential_profit_tp1 = abs(signal['targets'][0] - signal['entry_price']) / signal['entry_price'] * 100
857|            potential_profit_tp3 = abs(signal['targets'][2] - signal['entry_price']) / signal['entry_price'] * 100
858|            
859|            timestamp_str = datetime.now(timezone.utc).strftime('%d %b %Y, %H:%M UTC')
860|            
861|            # Ù¾ÛŒØ§Ù… Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ùˆ Ù…Ù†Ø¸Ù…
862|            message = f"{direction_emoji} *{direction_text} SIGNAL*\n"
863|            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
864|            
865|            message += f"ğŸ“Š *{symbol_name}* `{signal['symbol']}`\n"
866|            message += f"â± Timeframe: *{signal['timeframe'].upper()}*\n"
867|            message += f"ğŸ” Structure: `{signal['structure_type']}`\n\n"
868|            
869|            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
870|            message += f"*ENTRY ZONE*\n"
871|            message += f"ğŸ’µ `${signal['entry_price']:.6f}`\n\n"
872|            
873|            message += f"*TAKE PROFIT TARGETS*\n"
874|            for i, target in enumerate(signal['targets'], 1):
875|                if i == 1:
876|                    emoji = "ğŸ¯"
877|                elif i == 2:
878|                    emoji = "ğŸ’š"
879|                else:
880|                    emoji = "âœ¨"
881|                message += f"{emoji} TP{i}: `${target:.6f}`\n"
882|            
883|            message += f"\n*STOP LOSS*\n"
884|            message += f"ğŸ›‘ `${signal['stop_loss']:.6f}`\n\n"
885|            
886|            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
887|            message += f"*TRADE DETAILS*\n"
888|            message += f"âš–ï¸ Risk/Reward: `1:{rr_ratio:.1f}`\n"
889|            message += f"ğŸ“Š Leverage: `{signal['leverage']}x` (Conservative)\n"
890|            message += f"ğŸ’¹ Potential: `+{potential_profit_tp1:.1f}%` to `+{potential_profit_tp3:.1f}%`\n\n"
891|            
892|            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
893|            message += f"âš ï¸ *Risk Management:*\n"
894|            message += f"â€¢ Use proper position sizing\n"
895|            message += f"â€¢ Set stop loss immediately\n"
896|            message += f"â€¢ Take partial profits at each TP\n\n"
897|            
898|            message += f"ğŸ• {timestamp_str}\n"
899|            message += f"ğŸ“ˆ Smart Money Concept Analysis"
900|            
901|            # Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„
902|            sent_message = await self.bot.send_photo(
903|                chat_id=CHANNEL_ID,
904|                photo=chart_buffer,
905|                caption=message,
906|                parse_mode='Markdown'
907|            )
908|            
909|            # Ø°Ø®ÛŒØ±Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„
910|            await self.save_signal(signal, sent_message.message_id)
911|            
912|            logger.info(f"Signal sent: {symbol_name} {signal['direction']}")
913|            
914|        except TelegramError as e:
915|            logger.error(f"Telegram error: {e}")
916|        except Exception as e:
917|            logger.error(f"Error sending signal: {e}")
918|    
919|    async def scan_markets(self):
920|        """Ø§Ø³Ú©Ù† Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ ÛŒØ§ÙØªÙ† ÙØ±ØµØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø§ Ú©ÛŒÙÛŒØª Ø¨Ø§Ù„Ø§"""
921|        logger.info("ğŸ” Starting market scan...")
922|        
923|        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙØ¹Ø§Ù„
924|        active_trades = await self.check_active_trades()
925|        signals_found = 0
926|        
927|        for coin_id in SYMBOLS.keys():
928|            # Ø§Ú¯Ø± Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† coin Ù…Ø¹Ø§Ù…Ù„Ù‡ ÙØ¹Ø§Ù„ Ø¯Ø§Ø±ÛŒÙ…ØŒ Ø§Ø³Ú©Ù† Ù†Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
929|            if coin_id in active_trades:
930|                logger.info(f"â­ï¸ {coin_id}: Active trade exists, skipping...")
931|                continue
932|            
933|            for timeframe in TIMEFRAMES:
934|                try:
935|                    logger.info(f"ğŸ” Analyzing {coin_id} on {timeframe}...")
936|                    signal = self.analyzer.generate_signal(coin_id, timeframe)
937|                    
938|                    if signal:
939|                        logger.info(f"âœ… HIGH-QUALITY SIGNAL FOUND: {coin_id} {timeframe} {signal['direction']}")
940|                        await self.send_signal(signal)
941|                        signals_found += 1
942|                        
943|                        # Ø¨Ø±Ø§ÛŒ Ù‡Ø± coin ÙÙ‚Ø· ÛŒÚ© Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¯Ø± Ù‡Ø± Ø¨Ø§Ø± Ø§Ø³Ú©Ù†
944|                        break
945|                    
946|                    # Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒÙ… ØªØ§ rate limit Ù†Ø®ÙˆØ±ÛŒÙ…
947|                    await asyncio.sleep(2)
948|                    
949|                except Exception as e:
950|                    logger.error(f"âŒ Error scanning {coin_id} {timeframe}: {e}")
951|                    continue
952|        
953|        logger.info(f"âœ… Market scan completed. Signals found: {signals_found}")
954|    
955|    async def run(self):
956|        """Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª Ø¨Ø§ Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ"""
957|        logger.info("ğŸ¤– Crypto Signal Bot Starting...")
958|        logger.info("ğŸ“Š Strategy: Smart Money Concept (SMC)")
959|        logger.info("ğŸ¯ Focus: HIGH QUALITY signals only")
960|        
961|        # ØªØ³Øª Ø§ØªØµØ§Ù„
962|        try:
963|            me = await self.bot.get_me()
964|            logger.info(f"âœ… Bot connected: @{me.username}")
965|            logger.info(f"ğŸ“¢ Channel: {CHANNEL_ID}")
966|        except Exception as e:
967|            logger.error(f"âŒ Telegram connection failed: {e}")
968|            return
969|        
970|        while True:
971|            try:
972|                # Ø§Ø³Ú©Ù† Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§
973|                await self.scan_markets()
974|                
975|                # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙØ¹Ø§Ù„
976|                await self.monitor_active_trades()
977|                
978|                # Ø§Ø³ØªØ±Ø§Ø­Øª 5 Ø¯Ù‚ÛŒÙ‚Ù‡
979|                logger.info("â¸ï¸ Waiting 5 minutes before next scan...")
980|                await asyncio.sleep(300)
981|                
982|            except KeyboardInterrupt:
983|                logger.info("ğŸ›‘ Bot stopped by user")
984|                break
985|            except Exception as e:
986|                logger.error(f"âš ï¸ Unexpected error: {e}")
987|                await asyncio.sleep(60)
988|
989|
990|async def main():
991|    """ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ"""
992|    bot = TelegramSignalBot()
993|    await bot.run()
994|
995|
996|if __name__ == "__main__":
997|    asyncio.run(main())
998|
